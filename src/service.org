* 基本框架

Box service 是设备连接到系统的通道。设备通过 box service 上报数据；管理系统通过
box service 给设备发送命令。服务采用异步方式编写，启动后侦听 UDP/5008 端口，处理
收到的请求，并把响应返回给请求的设备；或者把任务数据下发给设备。

#+begin_src nim :exports code :noweb yes :mkdirp yes :tangle /dev/shm/box-service/src/box_service.nim
  import asyncdispatch, asyncnet, base64, httpclient, json, logging, md5, nativesockets, posix, redis, ringbuffer, sequtils, strfmt, strutils, tables, times
  import box_servicepkg/box_packer, box_servicepkg/parameter

  <<hexdump>>
  <<generate-pin>>
  <<check-base64>>

  type
    Task = tuple[uid: box_packer.UID, sockaddr: Sockaddr_in, data: seq[byte]]
    PinPair = tuple[pin: int16, expire_in: int64]

  var device_connections: Table[box_packer.UID, tuple[name: string, expires_at: int, sockaddr: Sockaddr_in]] = initTable[box_packer.UID, tuple[name: string, expires_at: int, sockaddr: Sockaddr_in]]()
  var task_buffer: RingBuffer[Task] = newRingBuffer[Task](bitsize = 10)
  var pin_table: Table[box_packer.UID, RingBuffer[PinPair]] = initTable[box_packer.UID, RingBuffer[PinPair]]()
  var L = newConsoleLogger(fmtStr = "$levelid [$datetime] : ")
  addHandler(L)

  proc prepareAddress(intaddr: uint32, intport: uint16): ptr Sockaddr_in =
    result = cast[ptr Sockaddr_in](alloc0(sizeof(Sockaddr_in)))
    result.sin_family = toInt(nativesockets.AF_INET)
    result.sin_port = nativesockets.htons(intport)
    result.sin_addr.s_addr = nativesockets.htonl(intaddr)

#+end_src

DevicePin 用于去除来自设备的重复命令。来自设备的命令都附带一个 PIN，如果该 PIN
在 pin_buffer 中存在，则说明该命令已经收到，此次请求可以忽略。

** send

发送任务数据到设备。发送任务检查 task_buffer 中的发送数据，有任务就发送到对应的
设备，没有就休眠 1 秒。

#+begin_src nim :exports code :noweb yes :mkdirp yes :tangle /dev/shm/box-service/src/box_service.nim
  proc send_always(sock: AsyncFD) {.async.} =
    let redis_client: AsyncRedis = await openAsync()
    var
      sndbuf: ref array[1024, byte] = new(array[1024, byte])
      address = newString(128)
      slen = sizeof(Sockaddr_in).SockLen
    while true:
      if len(task_buffer) > 0:
        let
          task = pop(task_buffer)
          name = await redis_client.hget("boxes", $task.uid)
          box = if name == redisNil: $task.uid else: $task.uid & "(" & name & ")"
        zeroMem(cast[pointer](sndbuf), 1024)
        let encoded = base64.encode[byte](task.data, lineLen = 1024)
        for i in 0..(len(encoded) - 1):
          sndbuf[i] = cast[uint8](ord(encoded[i]))
        var dst = task.sockaddr
        let sendto_future = send_to(socket = sock, data = cast[pointer](sndbuf), size = len(encoded), saddr = cast[ptr SockAddr](addr(dst)), saddrLen = slen)
        yield sendto_future
        if sendto_future.failed:
          device_connections.del(task.uid)
          error "Send ", len(encoded), " byte(s) to ", box, " @ ", address, ":", dst.sin_port, " failed"
          continue
        discard inet_ntop(posix.AF_INET, cast[pointer](addr dst.sin_addr), cstring(address), len(address).int32)
        address = address.strip(chars = {'\0'})
        info "Send ", len(encoded), " byte(s) to ", box, " @ ", address, ":", dst.sin_port, ": ", encoded
      else:
        await sleepAsync(1000)
#+end_src

** receive

从设备接收数据。在删除已发送成功任务时，要去 tasks-pending 里查找任务。

#+begin_src nim :exports code :noweb yes :mkdirp yes :tangle /dev/shm/box-service/src/box_service.nim
  proc receive_always(sock: AsyncFD) {.async.} =
    var
      rcvbuf: ref array[1024, byte] = new(array[1024, byte])
      address = newString(128)
      slen = sizeof(Sockaddr_in).SockLen
    let redis_client: AsyncRedis = await openAsync()
    while true:
      zeroMem(cast[pointer](rcvbuf), 1024)
      var saddr = Sockaddr_in()
      zeroMem(cast[pointer](addr(saddr)), sizeof(Sockaddr_in))
      let blen = await sock.recvFromInto(cast[pointer](rcvbuf), 1024, cast[ptr SockAddr](addr(saddr)), addr(slen))
      discard inet_ntop(posix.AF_INET, cast[pointer](addr saddr.sin_addr), cstring(address), len(address).int32)
      address = address.strip(chars = {'\0'})
      var received = ""
      for i in 0..blen - 1:
        received &= chr(rcvbuf[i])
      info "Received ", blen, " bytes: ", received
      if check_base64(rcvbuf, blen):
        info "Receive invalid base64 packet from ", address, ":", saddr.sin_port
        continue
      let rcvd: string = try: base64.decode($cast[cstring](rcvbuf)) except: nil
      if rcvd == nil:
        info "Decode invalid base64 packet from ", address, ":", saddr.sin_port
        continue
      for i in 0..len(rcvd) - 1:
        rcvbuf[i] = cast[uint8](ord(rcvd[i]))
      # info hexdump(@(rcvbuf[]), len(rcvd))
      var data: PackResult = box_packer.decode(@(rcvbuf[]), 0, len(rcvd))
      if data != nil:
        let
          name = await redis_client.hget("boxes", $data.uid)
          box = if name == redisNil: $data.uid else: $data.uid & "(" & name & ")"
        case data.cmd_type:
          of CommandType.PING:
            info "Receive PING from ", box, " @ ", address, ":", saddr.sin_port
            <<ping>>
          of CommandType.PONG:
            info "Receive PONG from ", box, " @ ", address, ":", saddr.sin_port
            <<pong>>
          of CommandType.CONFIRM:
            info "Receive CONFIRM of ", CommandType(data.parameter.cmd_type) , " from ", box, " @ ", address, ":", saddr.sin_port
            <<confirm>>
          of CommandType.LOCK_OFF:
            info "Receive LOCK_OFF from ", box, " @ ", address, ":", saddr.sin_port
            <<client-lock-off>>
          of CommandType.LOCK_DATA:
            info "Receive LOCK_DATA from ", box, " @ ", address, ":", saddr.sin_port
            <<lock-data>>
          of CommandType.EGG_FALLEN:
            info "Receive EGG_FALLEN from ", box, " @ ", address, ":", saddr.sin_port
            <<egg-fallen>>
          of CommandType.EGG_TIMEOUT:
            info "Receive EGG_TIMEOUT from ", box, " @ ", address, ":", saddr.sin_port
            <<egg-timeout>>
          else:
            info "Receive UNKNOWN from ", box, " @ ", address, ":", saddr.sin_port
      else:
        info "Receive invalid packet from ", address, ":", saddr.sin_port
#+end_src

** check task

检查任务队列。第一步，从已经建立连接的设备任务队列中获取任务，如果任务
过期了，就不发送任务，记录任务超时到日志中；否则，就根据任务的类型将任
务填充到 task_buffer 中，并记录发送时间到日志中。任务队列中的未超时的
任务由 receive 流程来删除。没有被删除的任务将持续发送到设备上，直到任
务超时。

先阶段，上诉的工作方式会在一个用户使用设备时，将设备锁住，直到操作完成，
receive 流程主动删除任务；或者任务超时，被 check task 流程删除。在设备
被锁住期间，所有任务都是不能发送给设备的，这样使得设备的实时性非常差。

为了提高实时性，在缓存上引入循环队列来保存任务。上述工作方式变为：

1. 当从原来的任务队列中收到一个 qos >= 1 的任务时，立刻发送给设备，同
   时把任务添加到循环任务队列的末尾。

2. 若循环队列不为空，则取出第一个不超时的任务发送给设备，同时把任务继
   续加入到循环队列的末尾。

3. 若 receive 流程收到任务的响应，则去循环队列中查找并删除任务。

要注意，check task 流程在检查循环队列时，要休眠恰当的时间（比如按队列
长度来计算休眠时间），以保证每个任务大概 3 秒钟可以重发一次。

#+begin_src nim :exports code :noweb yes :mkdirp yes :tangle /dev/shm/box-service/src/box_service.nim
  proc check_always() {.async.} =
    var address = newString(128)
    let redis_client: AsyncRedis = await openAsync()
    var sending_time: Table[box_packer.UID, int64] = initTable[box_packer.UID, int64]()
    var operation_count = 0
    while true:
      operation_count = 0 # did we do redis or send something?
      let
        now_in_ms = (epochTime() * 1024).toInt()
        now = now_in_ms shr 10
      for uid, pair in device_connections.pairs():
        let
          box = pair[0]
          expires_at = pair[1]
          dst = pair[2]
        if expires_at < now:
          warn "Connection of ", box, " is expired"
          device_connections.del(uid)
          continue
        let
          taskkey = "tasks." & $uid
          taskstr = await redis_client.rpop(taskkey)
        if taskstr == redisNil:
          #warn "Got nothing in task queue ", taskkey
          #info "Task queue ", taskkey, " is empty"
          <<handle-recycle-queue>>
        else:
          let task = try: parseJson(taskstr) except: nil
          if task != nil:
            operation_count += 1
            let qos = if task.has_key("qos") and task["qos"].getStr() == "<=1": "<=1" else: ">=1"
            if qos == ">=1" and task["expires-at"].getInt() < now:
              # send a ping command to box device to check network status
              let
                pin = generate_pin(1)
                jobkey = "tasks." & $uid
                logkey = "tasklog." & $uid & "." & getDateStr()
                #job = %*{"command": "ping", "qos": "<=1", "expires-at": epochTime().toInt() + 5, "pin": pin, "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
                job = %*{"command": "ping", "qos": "<=1", "expires-at": now + 5, "pin": pin, "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}
              await redis_client.multi()
              discard await redis_client.rpush(key = jobkey, value = $job)
              discard await redis_client.expire(key = jobkey, seconds = 86400)
              discard await redis_client.rpush(key = logkey, value = $job)
              discard await redis_client.exec()
              task["status"] = % "expired"
              task["occurred-at"] = %(getDateStr() & " " & getClockStr())
              discard await redis_client.rpush(logkey, $task)
              info "Remove expired task ", taskstr, " from ", taskkey, " of ", box
              <<handle-recycle-queue>>
            else:
              let pendingkey = "tasks-pending." & $uid
              let
                tasklog_key = "tasklog." & $uid & "." & getDateStr()
                tasklog_len = cast[int](await redis_client.llen(tasklog_key))
                tasklogs = if tasklog_len > 100: await redis_client.lrange(tasklog_key, tasklog_len - 100, tasklog_len - 1) else: await redis_client.lrange(tasklog_key, 0, -1)
              var found_log = false
              for logstr in tasklogs:
                let log = try: parseJson(logstr) except: nil
                if log != nil and task["command"].getStr() == log["command"].getStr() and task["expires-at"].getInt() == log["expires-at"].getInt():
                  if log.has_key("pin") and task.has_key("pin") and log["pin"].getInt() == task["pin"].getInt():
                    if log["status"].getStr() == "sending":
                      found_log = true
                      break
                  elif log.has_key("pins") and task.has_key("pins") and len(log["pins"]) == len(task["pins"]):
                    var found_pins = true
                    for i in 0..len(log["pins"]) - 1:
                      if log["pins"][i].getInt() != task["pins"][i].getInt():
                        found_pins = false
                        break
                    if found_pins and log["status"].getStr() == "sending":
                      found_log = true
                      break
              if not found_log:
                task["status"] = % "sending"
                task["occurred-at"] = %(getDateStr() & " " & getClockStr())
                discard await redis_client.rpush(tasklog_key, $task)
              let plen = await redis_client.llen(pendingkey)
              if qos == ">=1":
                # save task to recycle queue
                discard await redis_client.lpush(pendingkey, $task)
                if plen > 1:
                  <<handle-recycle-queue>>
                else:
                  <<handle-tasks>>
              else:
                <<handle-tasks>>
                if plen > 1:
                  <<handle-recycle-queue>>
          else:
            <<handle-recycle-queue>>
      if operation_count == 0:
        await sleepAsync(1000)
#+end_src


*** 处理循环队列
#+begin_src nim :noweb-ref handle-recycle-queue
  let pendingkey = "tasks-pending." & $uid
  if sending_time.contains(uid):
    let
      redis_pendinglen = await redis_client.llen(pendingkey)
      pendinglen = cast[int](redis_pendinglen)
      interval = int(3000 / (if pendinglen == 0: 1 else: pendinglen))
    if now_in_ms - sending_time[uid] < interval: # Don't resend in interval microseconds
      continue
  sending_time[uid] = now_in_ms
  let taskstr = await redis_client.rpoplpush(pendingkey, pendingkey)
  if taskstr != redisNil:
    operation_count += 1
    let task = try: parseJson(taskstr) except: nil
    if task == nil:
      discard await redis_client.lpop(pendingkey)
      continue
    if task["expires-at"].getInt() < now:
      let
        pin = generate_pin(1)
        logkey = "tasklog." & $uid & "." & getDateStr()
      task["status"] = % "expired"
      task["occurred-at"] = %(getDateStr() & " " & getClockStr())
      await redis_client.multi()
      discard await redis_client.lpop(pendingkey)
      discard await redis_client.rpush(key = logkey, value = $task)
      discard await redis_client.exec()
      info "Remove expired task ", taskstr, " from ", pendingkey, " of ", box
    else:
      <<handle-tasks>>
#+end_src

*** 处理任务
#+begin_src nim :noweb-ref handle-tasks
  case task["command"].getStr():
    of "lock-off":
      <<lock-off>>
    of "locks-off":
      <<locks-off>>
    of "lock-status":
      <<lock-status>>
    of "lock-detect":
      <<lock-detect>>
    of "lock-status-detect":
      <<lock-status-detect>>
    of "light-on":
      <<light-on>>
    of "light-off":
      <<light-off>>
    of "fan-on":
      <<fan-on>>
    of "fan-off":
      <<fan-off>>
    of "ultraviolet-on":
      <<ultraviolet-on>>
    of "ultraviolet-off":
      <<ultraviolet-off>>
    of "camera-on":
      <<camera-on>>
    of "camera-off":
      <<camera-off>>
    of "charger-status":
      <<charger-status>>
    of "charger-config":
      <<charger-config>>
    of "config-charger":
      <<config-charger>>
    of "play":
      <<play>>
    of "volume":
      <<volume>>
    of "volume-up":
      <<volume-up>>
    of "volume-down":
      <<volume-down>>
    of "config-network":
      <<config-network>>
    of "reboot":
      <<reboot>>
    of "ping":
      <<service-ping>>
    of "egg-lock-on":
      <<egg-lock-on>>
    of "egg-lock-off":
      <<egg-lock-off>>
    of "egg-play":
      <<egg-play>>
    of "egg-gpio":
      <<egg-gpio>>
    of "egg-volume":
      <<egg-volume>>
    of "egg-query":
      <<egg-query>>
    else:
      discard await redis_client.rpop(pendingkey)
#+end_src


** serve

启动程序

#+begin_src nim :exports code :noweb yes :mkdirp yes :tangle /dev/shm/box-service/src/box_service.nim
  proc serve() =
    var
      name = prepareAddress(INADDR_ANY, 5008)
      sock = newAsyncNativeSocket(domain = Domain.AF_INET, sockType = SockType.SOCK_DGRAM, protocol = Protocol.IPPROTO_UDP)

    discard bindAddr(sock.SocketHandle, cast[ptr SockAddr](name), sizeof(Sockaddr_in).Socklen)
    info "Server bound to port 5008"

    asyncCheck receive_always(sock)
    asyncCheck send_always(sock)
    asyncCheck check_always()
    run_forever()

  serve()
#+end_src

* PING

为了保持数据链路的畅通，设备会定时往 box service 发送 PING 命令。Box service 返
回 PONG 命令，把当前时间返回给设备。

#+begin_src nim :noweb-ref ping
  let
    uid = data.uid
    param = data.parameter
    sn = param.sn
    version = param.version
    apikey = "api." & $uid
  <<save-connections>>
  <<save-network-status>>
  await redis_client.setk(apikey, $version)
  var pong_param: ref Parameter = new(Parameter)
  pong_param.sn = sn
  pong_param.version = 0
  pong_param.zone = 8 * 60 * 60 * 1000
  pong_param.timestamp = cast[int64]((epochTime() * 1000).toInt())
  var pkt = pong_param.encode_as(CommandType.PONG, uid)
  discard task_buffer.add((uid: uid, sockaddr: saddr, data: pkt))
  info "Prepare to send PONG to ", box, " @ ", address, ":", saddr.sin_port
#+end_src
* SERVICE-PING
服务也会给设备发送 PING，以便探知设备是否掉线。
#+begin_src nim :noweb-ref service-ping
  var ping: ref Parameter = new(Parameter)
  ping.pin = cast[int16](task["pin"].getInt())
  ping.zone = 8 * 60 * 60 * 1000
  ping.timestamp = cast[int64]((epochTime() * 1000).toInt())
  var pkt = ping.encode_as(CommandType.PING, uid)
  discard task_buffer.add((uid: uid, sockaddr: dst, data: pkt))
  var saddr = dst
  <<ntop>>
  info "Prepare to send PING(pin: ", cast[uint16](ping.pin) , ") to ", box, " @ ", address, ":", dst.sin_port
#+end_src
* PONG

当 box service 给设备发送 PING 命令后，设备会给服务器返回 PONG 命令。
通过这种方式，box service 可以主动探知设备是否在线。

#+begin_src nim :noweb-ref pong
  let
    uid = data.uid
    param = data.parameter
    sn = param.sn
  <<save-connections>>
  <<save-network-status>>

  let
    taskkey = "tasks-pending." & $uid
    taskstrs: seq[string] = await redis_client.lrange(taskkey, 0, -1)
  if len(taskstrs) != 0:
    for taskstr in taskstrs:
      let task = try: parseJson(taskstr) except: nil
      if task != nil and task["command"].getStr() == "ping" and cast[int16](task["pin"].getInt()) == param.pin:
        <<remove-task>>
#+end_src
* CONFIRM
  收到设备发回的 CONFIRM 后，box service 去任务队列中查找对应的任务，并将其从任务
队列中删除。
#+begin_src nim :noweb-ref confirm
  let
    uid = data.uid
    param = data.parameter
    sn = param.sn
    name = await redis_client.hget("boxes", $uid)
  <<save-connections>>
  <<save-network-status>>
  let
    taskkey = "tasks-pending." & $uid
    cmd_type = case param.cmd_type:
                 of 0: CommandType.UNKNOWN
                 of 1: CommandType.PING
                 of 2: CommandType.PONG
                 of 3: CommandType.CONFIRM
                 of 4: CommandType.LOCK_OFF
                 of 5: CommandType.LOCKS_OFF
                 of 6: CommandType.LOCK_STATUS
                 of 7: CommandType.LOCK_DETECT
                 of 8: CommandType.LOCK_STATUS_DETECT
                 of 9: CommandType.CHARGER_STATUS
                 of 10: CommandType.LIGHT_ON
                 of 11: CommandType.LIGHT_OFF
                 of 12: CommandType.FAN_ON
                 of 13: CommandType.FAN_OFF
                 of 14: CommandType.ULTRAVIOLET_ON
                 of 15: CommandType.ULTRAVIOLET_OFF
                 of 16: CommandType.CAMERA_ON
                 of 17: CommandType.CAMERA_OFF
                 of 18: CommandType.LOCK_DATA
                 of 19: CommandType.PLAY
                 of 20: CommandType.VOLUME_UP
                 of 21: CommandType.VOLUME_DOWN
                 of 22: CommandType.CONFIG_NETWORK
                 of 23: CommandType.VOLUME
                 of 24: CommandType.CHARGER_CONFIG
                 of 25: CommandType.CONFIG_CHARGER
                 of 26: CommandType.EGG_LOCK_ON
                 of 27: CommandType.EGG_LOCK_OFF
                 of 28: CommandType.EGG_PLAY
                 of 29: CommandType.EGG_GPIO
                 of 30: CommandType.EGG_FALLEN
                 of 31: CommandType.EGG_VOLUME
                 of 32: CommandType.EGG_TIMEOUT
                 of 33: CommandType.EGG_QUERY
                 of 63: CommandType.REBOOT
                 else: CommandType.UNKNOWN
  let taskstrs: seq[string] = await redis_client.lrange(taskkey, 0, -1)
  if len(taskstrs) == 0:
    info "Nothing in task queue ", taskkey, (if name != redisNil: " of " & name: else: "")
  case cmd_type:
    of CommandType.LOCK_OFF:
      <<lock-off-confirm>>
    of CommandType.LOCKS_OFF:
      <<locks-off-confirm>>
    of CommandType.LOCK_STATUS:
      <<lock-status-confirm>>
    of CommandType.LOCK_DETECT:
      <<lock-detect-confirm>>
    of CommandType.LOCK_STATUS_DETECT:
      <<lock-status-detect-confirm>>
    of CommandType.LIGHT_ON:
      <<light-on-confirm>>
    of CommandType.LIGHT_OFF:
      <<light-off-confirm>>
    of CommandType.FAN_ON:
      <<fan-on-confirm>>
    of CommandType.FAN_OFF:
      <<fan-off-confirm>>
    of CommandType.ULTRAVIOLET_ON:
      <<ultraviolet-on-confirm>>
    of CommandType.ULTRAVIOLET_OFF:
      <<ultraviolet-off-confirm>>
    of CommandType.CAMERA_ON:
      <<camera-on-confirm>>
    of CommandType.CAMERA_OFF:
      <<camera-off-confirm>>
    of CommandType.CHARGER_STATUS:
      <<charger-status-confirm>>
    of CommandType.CHARGER_CONFIG:
      <<charger-config-confirm>>
    of CommandType.CONFIG_CHARGER:
      <<config-charger-confirm>>
    of CommandType.PLAY:
      <<play-confirm>>
    of CommandType.VOLUME_UP:
      <<volume-up-confirm>>
    of CommandType.VOLUME_DOWN:
      <<volume-down-confirm>>
    of CommandType.CONFIG_NETWORK:
      <<config-network-confirm>>
    of CommandType.VOLUME:
      <<volume-confirm>>
    of CommandType.EGG_LOCK_ON:
      <<egg-lock-on-confirm>>
    of CommandType.EGG_LOCK_OFF:
      <<egg-lock-off-confirm>>
    of CommandType.EGG_PLAY:
      <<egg-play-confirm>>
    of CommandType.EGG_GPIO:
      <<egg-gpio-confirm>>
    of CommandType.EGG_VOLUME:
      <<egg-volume-confirm>>
    of CommandType.EGG_QUERY:
      <<egg-query-confirm>>
    of CommandType.REBOOT:
      <<reboot-confirm>>
    else:
      warn "Invalid command ", param.cmd_type, " from ", box
#+end_src

在确认的同时，需要确认消息记录到日志中。

#+begin_src nim :noweb-ref update-status-to-sent
  task["status"] = %"sent"
  task["occurred-at"] = %(getDateStr() & " " & getClockStr())
  discard await redis_client.rpush("tasklog." & $uid & "." & getDateStr(), $task)
#+end_src

* CLIENT-LOCK-OFF
从客户端发来的开锁指令，需要转发到业务系统去。服务把业务系统返回的结果编号转化为
对应的音频播放指令，保存到对应的任务队列中。播放指令在任务队列中保存 10 秒，超过
后自动删除。

#+begin_src nim :noweb-ref client-lock-off
  let
    uid = data.uid
    param = data.parameter
    sn = param.sn
    name = await redis_client.hget("boxes", $uid)
    lock = param.lock
    door = param.door
    reader = param.card_reader
    card_no = cast[uint32](param.card_no)
    pin = param.pin
  <<save-connections>>
  var confirm: ref Parameter = new(Parameter)
  confirm.sn = sn
  confirm.version = 0
  confirm.cmd_type = ord(CommandType.LOCK_OFF)
  confirm.lock = lock
  confirm.door = door
  confirm.card_reader = reader
  confirm.card_no = confirm.card_no
  confirm.timestamp = cast[int64]((epochTime() * 1000).toInt())
  confirm.pin = pin
  let pkt = confirm.encode_as(CommandType.CONFIRM, uid)
  discard task_buffer.add((uid: uid, sockaddr: saddr, data: pkt))
  info "Prepare to send CONFIRM of LOCK_OFF to ", box, " @ ", address, ":", saddr.sin_port
  let timestamp = epochTime().toInt()
  #if param.timestamp + 5000 < timestamp * 1000:
  if pin_table.contains(uid) and (pin_table[uid].find((pin: pin, expire_in: 0'i64)) do (a, b: PinPair) -> bool: a.pin == b.pin) != -1 and pin_table[uid][pin_table[uid].find((pin: pin, expire_in: 0'i64)) do (a, b: PinPair) -> bool: a.pin == b.pin].expire_in > timestamp:
    info "Found dup command LOCK_OFF from reader ", reader, " at ", uid
  else:
    info "A new fresh LOCK_OFF(card-reader: ", reader , ", door: ", lock, ") from ", uid
    if not pin_table.contains(uid):
      pin_table[uid] = newRingBuffer[PinPair](bitsize = 3)
    else:
      while len(pin_table[uid]) > 0 and pin_table[uid][0][1] < timestamp:
        discard pin_table[uid].pop()
    while pin_table[uid].add((pin: pin, expire_in: cast[int64](timestamp + 6))) == 0:
      discard pin_table[uid].pop()
    info "Add pin of LOCK_OFF to ringbuffer"
    let
      bsclient = newAsyncHttpClient()
      card_no_str = card_no.format("-010")
      params = if lock == 0 and door == 0: "mb=" & $uid & "&sw=" & $reader & "&t=" & $timestamp & "&u=" & card_no_str elif lock == 0: "mb=" & $uid & "&sno=" & $door & "&sw=" & $reader & "&t=" & $timestamp & "&u=" & card_no_str else: "mb=" & $uid & "&sno=" & $lock & "&sw=" & $reader & "&t=" & $timestamp & "&u=" & card_no_str
      path = if lock == 0 and door == 0: "swing/back" else: "swing/orsark"
      sign = toLowerAscii($toMD5(params & "&key=qbtstvvs05pyiwjj50uuddydho2srdlm"))
    bsclient.headers = newHttpHeaders({ "Content-Type": "application/x-www-form-urlencoded" })
    info "https://book.fengchaohuzhu.com/" & path
    let response = await bsclient.post("https://book.fengchaohuzhu.com/" & path, body = params & "&sign=" & sign)
    info params & "&sign=" & sign
    bsclient.close()
    info "Business system response status ", response.status
    if response.status == "200 OK":
      let body = await response.body()
      let resp = try: parseJson(body) except: nil
      if resp != nil:
        info "Business system response ", $resp
        let
          tkey = "tasks." & $uid
          audio = if lock == 0:
                    case resp["code"].getInt():
                      of 1: 10
                      of -318: 12
                      of -350: 12
                      of -208: 7
                      of -138: 8
                      of -83: 13
                      of -339: 13
                      of -340: 13
                      of -1: 13
                      of -79: 13
                      of -80: 14
                      else: 0
                  else:
                    case resp["code"].getInt():
                      of 1: 4
                      of -341: 5
                      of -137: 6
                      of -208: 7
                      of -135: 8
                      of -142: 9
                      of -83: 13
                      of -1: 13
                      of -4: 13
                      of -79: 6
                      of -80: 13
                      of -339: 13
                      of -340: 13
                      else: 0
        if audio != 0:
          let json = %*{"command": "play", "speaker": reader, "audio": audio, "pin": pin, "expires-at": epochTime().toInt() + 10, "pin": pin, "status": "queued", "occurred-at": getDateStr() & " " & getClockStr()}

          await redis_client.multi()
          discard await redis_client.rpush(key = tkey, value = $json)
          discard await redis_client.expire(key = tkey, seconds = 86400)
          discard await redis_client.rpush(key = "tasklog." & $uid & "." & getDateStr(), value = $json)
          discard await redis_client.exec()
#+end_src

* LOCK-OFF
** 下行命令
#+begin_src nim :noweb-ref lock-off
  var lock_off: ref Parameter = new(Parameter)
  lock_off.board = cast[int8](task["board"].getInt())
  lock_off.lock = cast[int8](task["lock"].getInt())
  lock_off.pin = cast[int16](task["pin"].getInt())
  lock_off.zone = 8 * 60 * 60 * 1000
  lock_off.timestamp = cast[int64]((epochTime() * 1000).toInt())
  var pkt = lock_off.encode_as(CommandType.LOCK_OFF, uid)
  discard task_buffer.add((uid: uid, sockaddr: dst, data: pkt))
  var saddr = dst
  <<ntop>>
  info "Prepare to send LOCK_OFF(board: ", lock_off.board, ", lock: ", lock_off.lock , ", pin: ", cast[uint16](lock_off.pin) , ") to ", box, " @ ", address, ":", dst.sin_port
#+end_src
** 上行响应
#+begin_src nim :noweb-ref lock-off-confirm
  info "Confirm cmd type is LOCK_OFF, board: ", param.board, ", lock: ", param.lock
  if param.pin != 0:
    discard await redis_client.setEx("lock-off-ack." & $uid & "." & $cast[uint16](param.pin), 30, $param.timestamp)
  for taskstr in taskstrs:
    let task = try: parseJson(taskstr) except: nil
    if task != nil and task["command"].getStr() == "lock-off" and cast[int8](task["board"].getInt()) == param.board and cast[int8](task["lock"].getInt()) == param.lock:
      <<remove-task>>
#+end_src
* LOCKS-OFF
** 下行命令
#+begin_src nim :noweb-ref locks-off
  var locks_off: ref Parameter = new(Parameter)
  locks_off.board = cast[int8](task["board"].getInt())
  locks_off.locks = task["locks"].getElems().mapIt(cast[int8](it.getInt()))
  locks_off.pin = cast[int16](task["pin"].getInt())
  locks_off.pins = task["pins"].getElems().mapIt(cast[int16](it.getInt()))
  locks_off.zone = 8 * 60 * 60 * 1000
  locks_off.timestamp = cast[int64]((epochTime() * 1000).toInt())
  var pkt = locks_off.encode_as(CommandType.LOCKS_OFF, uid)
  discard task_buffer.add((uid: uid, sockaddr: dst, data: pkt))
  var saddr = dst
  <<ntop>>
  info "Prepare to send LOCKS_OFF(board: ", locks_off.board, ", locks: ", locks_off.locks, ", pins: ", locks_off.pins.mapIt(cast[uint16](it)), ") to ", box, " @ ", address
#+end_src
** 上行响应
#+begin_src nim :noweb-ref locks-off-confirm
  info "Confirm cmd type is LOCKS_OFF, board: ", param.board, ", locks: ", param.locks.mapIt($it).join(",")
  if param.pin != 0:
    discard await redis_client.setEx("locks-off-ack." & $uid & "." & $cast[uint16](param.pin), 30, $param.timestamp)
  for taskstr in taskstrs:
    let task = try: parseJson(taskstr) except: nil
    if task != nil and task["command"].getStr() == "locks-off" and cast[int8](task["board"].getInt()) == param.board:
      if len(param.pins) > 0 and param.pins[0] == cast[int16](task["pins"][0].getInt()):
        <<remove-task>>
      elif param.pin != 0 and param.pin == cast[int16](task["pins"][0].getInt()):
        <<remove-task>>
#+end_src
* LOCK-STATUS
** 下行命令
#+begin_src nim :noweb-ref lock-status
  var lock_status: ref Parameter = new(Parameter)
  lock_status.board = cast[int8](task["board"].getInt())
  lock_status.pin = cast[int16](task["pin"].getInt())
  lock_status.zone = 8 * 60 * 60 * 1000
  lock_status.timestamp = cast[int64]((epochTime() * 1000).toInt())
  var pkt = lock_status.encode_as(CommandType.LOCK_STATUS, uid)
  discard task_buffer.add((uid: uid, sockaddr: dst, data: pkt))
  var saddr = dst
  <<ntop>>
  info "Prepare to send LOCK_STATUS(board: ", lock_status.board, ", pin: ", cast[uint16](lock_status.pin), ") to ", box, " @ ", address, ":", dst.sin_port
#+end_src
** 上行响应
#+begin_src nim :noweb-ref lock-status-confirm
  let locksystem = await redis_client.get("locksystem." & $uid)
  info "Confirm cmd type is LOCK_STATUS ", locksystem, ", board: ", param.board, ", state0: ", param.states[0].toHex(), ", state1: ", param.states[1].toHex(), ", state2: ", param.states[2].toHex()
  await redis_client.multi()
  for i in 0..len(param.states) - 1:
    var state = param.states[i]
    var skey = "lock-status." & $uid & "." & $param.board & "." & $i
    discard await redis_client.setEx(skey, 5, $state)
  discard await redis_client.exec()
  for taskstr in taskstrs:
    let task = try: parseJson(taskstr) except: nil
    if task != nil and task["command"].getStr() == "lock-status" and cast[int8](task["board"].getInt()) == param.board and cast[int16](task["pin"].getInt()) == param.pin:
      <<remove-task>>
#+end_src
* LOCK-DETECT
** 下行命令
#+begin_src nim :noweb-ref lock-detect
  var lock_detect: ref Parameter = new(Parameter)
  lock_detect.board = cast[int8](task["board"].getInt())
  lock_detect.pin = cast[int16](task["pin"].getInt())
  lock_detect.zone = 8 * 60 * 60 * 1000
  lock_detect.timestamp = cast[int64]((epochTime() * 1000).toInt())
  var pkt = lock_detect.encode_as(CommandType.LOCK_DETECT, uid)
  discard task_buffer.add((uid: uid, sockaddr: dst, data: pkt))
  var saddr = dst
  <<ntop>>
  info "Prepare to send LOCK_DETECT(board: ", lock_detect.board, ", pin: ", cast[uint16](lock_detect.pin), ") to ", box, " @ ", address, ":", dst.sin_port
#+end_src
** 上行响应
#+begin_src nim :noweb-ref lock-detect-confirm
  info "Confirm cmd type is LOCK_DETECT, board: ", param.board, ", state0: ", param.states[0], ", state1: ", param.states[1], ", state2: ", param.states[2]
  for i in 0..len(param.states) - 1:
    var state = param.states[i]
    for j in 0..7:
      var skey = "lock-detect." & $uid & "." & $param.board & "." & $((len(param.states) - 1 - i) * 8 + j + 1)
      if ((1 shl j) and state) != 0:
        discard await redis_client.setEx(skey, 5, "1")
      else:
        discard await redis_client.setEx(skey, 5, "0")
  for taskstr in taskstrs:
    let task = try: parseJson(taskstr) except: nil
    if task != nil and task["command"].getStr() == "lock-detect" and cast[int8](task["board"].getInt()) == param.board:
      <<remove-task>>
#+end_src
* LOCK-STATUS-DETECT
** 下行命令
#+begin_src nim :noweb-ref lock-status-detect
  var lock_status: ref Parameter = new(Parameter)
  lock_status.board = cast[int8](task["board"].getInt())
  lock_status.pin = cast[int16](task["pin"].getInt())
  lock_status.zone = 8 * 60 * 60 * 1000
  lock_status.timestamp = cast[int64]((epochTime() * 1000).toInt())
  var pkt = lock_status.encode_as(CommandType.LOCK_STATUS_DETECT, uid)
  discard task_buffer.add((uid: uid, sockaddr: dst, data: pkt))
  var saddr = dst
  <<ntop>>
  info "Prepare to send LOCK_STATUS_DETECT(board: ", lock_status.board, ", pin: ", cast[uint16](lock_status.pin), ") to ", box, " @ ", address, ":", dst.sin_port
#+end_src
** 上行响应

响应里包括两个部分的数据，states 里存放的是锁的状态，locks 里存放的是测物条的状态

#+begin_src nim :noweb-ref lock-status-detect-confirm
  info "Confirm cmd type is LOCK_STATUS_DETECT, board: ", param.board, ", status: ", param.states[0], ", ", param.states[1], ", ", param.states[2], ", detect: ", param.locks[0], ", ", param.locks[1], ", ", param.locks[2]
  for i in 0..len(param.states) - 1:
    var state = param.states[i]
    for j in 0..7:
      var skey = "lock-status." & $uid & "." & $param.board & "." & $((len(param.states) - 1 - i) * 8 + j + 1)
      if ((1 shl j) and state) != 0:
        discard await redis_client.setEx(skey, 5, "1")
      else:
        discard await redis_client.setEx(skey, 5, "0")
  for i in 0..len(param.locks) - 1:
    var state = param.locks[i]
    for j in 0..7:
      var skey = "lock-detect." & $uid & "." & $param.board & "." & $((len(param.locks) - 1 - i) * 8 + j + 1)
      if ((1 shl j) and state) != 0:
        discard await redis_client.setEx(skey, 5, "1")
      else:
        discard await redis_client.setEx(skey, 5, "0")
  for taskstr in taskstrs:
    let task = try: parseJson(taskstr) except: nil
    if task != nil and task["command"].getStr() == "lock-status-detect" and cast[int8](task["board"].getInt()) == param.board:
      <<remove-task>>
#+end_src
* LOCK-DATA
设备定时把锁控板的状态上报给服务端，服务端把这些状态同步到缓存中。
** 上行命令
#+begin_src nim :noweb-ref lock-data
  let
    uid = data.uid
    param = data.parameter
    sn = param.sn
    pin = param.pin
    now = cast[int]((epochTime() * 1000).toInt() shr 10)
    timestamp = cast[int](param.timestamp shr 10)
    expires_in = if now >= timestamp: 3600 else: timestamp - now
    locksystem = await redis_client.get("locksystem." & $uid)
  <<save-connections>>

  info "LOCK-DATA, ", locksystem, " board: ", param.board, ", status: ", cast[uint8](param.states[0]), ", ", cast[uint8](param.states[1]), ", ", cast[uint8](param.states[2])
  await redis_client.multi()
  for i in 0..len(param.states) - 1:
    var state = param.states[i]
    var skey = "lock-status." & $uid & "." & $param.board & "." & $i
    discard await redis_client.setEx(skey, expires_in, $state)
  discard await redis_client.exec()
  <<lock-data-confirm>>
#+end_src
** 下行响应
#+begin_src nim :noweb-ref lock-data-confirm
  var confirm_param: ref Parameter = new(Parameter)
  confirm_param.sn = sn
  confirm_param.pin = pin
  confirm_param.version = 0
  confirm_param.cmd_type = 18 # CommandType.LOCK_DATA
  confirm_param.zone = 8 * 60 * 60 * 1000
  confirm_param.timestamp = cast[int64]((epochTime() * 1000).toInt())
  var pkt = confirm_param.encode_as(CommandType.CONFIRM, uid)
  discard task_buffer.add((uid: uid, sockaddr: saddr, data: pkt))
  info "Prepare to send CONFIRM of LOCK_DATA to ", box, " @ ", address, ":", saddr.sin_port
#+end_src

* LIGHT-ON
** 下行命令
#+begin_src nim :noweb-ref light-on
  var light_on: ref Parameter = new(Parameter)
  light_on.pin = cast[int16](task["pin"].getInt())
  light_on.zone = 8 * 60 * 60 * 1000
  light_on.timestamp = cast[int64]((epochTime() * 1000).toInt())
  var pkt = light_on.encode_as(CommandType.LIGHT_ON, uid)
  discard task_buffer.add((uid: uid, sockaddr: dst, data: pkt))
  var saddr = dst
  <<ntop>>
  info "Prepare to send LIGHT_ON(pin: ", cast[uint16](light_on.pin), ") to ", box, " @ ", address, ":", dst.sin_port
#+end_src
** 上行响应
#+begin_src nim :noweb-ref light-on-confirm
  info "Confirm cmd type is LIGHT_ON"
  for taskstr in taskstrs:
    let task = try: parseJson(taskstr) except: nil
    if task != nil and task["command"].getStr() == "light-on":
      <<remove-task>>
#+end_src
* LIGHT-OFF
** 下行命令
#+begin_src nim :noweb-ref light-off
  var light_off: ref Parameter = new(Parameter)
  light_off.pin = cast[int16](task["pin"].getInt())
  light_off.zone = 8 * 60 * 60 * 1000
  light_off.timestamp = cast[int64]((epochTime() * 1000).toInt())
  var pkt = light_off.encode_as(CommandType.LIGHT_OFF, uid)
  discard task_buffer.add((uid: uid, sockaddr: dst, data: pkt))
  var saddr = dst
  <<ntop>>
  info "Prepare to send LIGHT_Off(pin: ", cast[uint16](light_off.pin), ") to ", box, " @ ", address, ":", dst.sin_port
#+end_src
** 上行响应
#+begin_src nim :noweb-ref light-off-confirm
  info "Confirm cmd type is LIGHT_OFF"
  for taskstr in taskstrs:
    let task = try: parseJson(taskstr) except: nil
    if task != nil and task["command"].getStr() == "light-off":
      <<remove-task>>
#+end_src
* FAN-ON
** 下行命令
#+begin_src nim :noweb-ref fan-on
  var fan_on: ref Parameter = new(Parameter)
  fan_on.pin = cast[int16](task["pin"].getInt())
  fan_on.zone = 8 * 60 * 60 * 1000
  fan_on.timestamp = cast[int64]((epochTime() * 1000).toInt())
  var pkt = fan_on.encode_as(CommandType.FAN_ON, uid)
  discard task_buffer.add((uid: uid, sockaddr: dst, data: pkt))
  var saddr = dst
  <<ntop>>
  info "Prepare to send FAN_ON(pin: ", cast[uint16](fan_on.pin), ") to ", box, " @ ", address, ":", dst.sin_port
#+end_src
** 上行响应
#+begin_src nim :noweb-ref fan-on-confirm
  info "Confirm cmd type is FAN_ON"
  for taskstr in taskstrs:
    let task = try: parseJson(taskstr) except: nil
    if task != nil and task["command"].getStr() == "fan-on":
      <<remove-task>>
#+end_src
* FAN-OFF
** 下行命令
#+begin_src nim :noweb-ref fan-off
  var fan_off: ref Parameter = new(Parameter)
  fan_off.pin = cast[int16](task["pin"].getInt())
  fan_off.zone = 8 * 60 * 60 * 1000
  fan_off.timestamp = cast[int64]((epochTime() * 1000).toInt())
  var pkt = fan_off.encode_as(CommandType.FAN_OFF, uid)
  discard task_buffer.add((uid: uid, sockaddr: dst, data: pkt))
  var saddr = dst
  <<ntop>>
  info "Prepare to send FAN_OFF(pin: ", cast[uint16](fan_off.pin), ") to ", box, " @ ", address, ":", dst.sin_port
#+end_src
** 上行响应
#+begin_src nim :noweb-ref fan-off-confirm
  info "Confirm cmd type is FAN_OFF"
  for taskstr in taskstrs:
    let task = try: parseJson(taskstr) except: nil
    if task != nil and task["command"].getStr() == "fan-off":
      <<remove-task>>
#+end_src
* ULTRAVIOLET-ON
** 下行命令
#+begin_src nim :noweb-ref ultraviolet-on
  var ultraviolet_on: ref Parameter = new(Parameter)
  ultraviolet_on.pin = cast[int16](task["pin"].getInt())
  ultraviolet_on.zone = 8 * 60 * 60 * 1000
  ultraviolet_on.timestamp = cast[int64]((epochTime() * 1000).toInt())
  var pkt = ultraviolet_on.encode_as(CommandType.ULTRAVIOLET_ON, uid)
  discard task_buffer.add((uid: uid, sockaddr: dst, data: pkt))
  var saddr = dst
  <<ntop>>
  info "Prepare to send ULTRAVIOLET_ON(pin: ", cast[uint16](ultraviolet_on.pin), ") to ", box, " @ ", address, ":", dst.sin_port
#+end_src
** 上行响应
#+begin_src nim :noweb-ref ultraviolet-on-confirm
  info "Confirm cmd type is ULTRAVIOLET_ON"
  for taskstr in taskstrs:
    let task = try: parseJson(taskstr) except: nil
    if task != nil and task["command"].getStr() == "ultraviolet-on":
      <<remove-task>>
#+end_src
* ULTRAVIOLET-OFF
** 下行命令
#+begin_src nim :noweb-ref ultraviolet-off
  var ultraviolet_off: ref Parameter = new(Parameter)
  ultraviolet_off.pin = cast[int16](task["pin"].getInt())
  ultraviolet_off.zone = 8 * 60 * 60 * 1000
  ultraviolet_off.timestamp = cast[int64]((epochTime() * 1000).toInt())
  var pkt = ultraviolet_off.encode_as(CommandType.ULTRAVIOLET_OFF, uid)
  discard task_buffer.add((uid: uid, sockaddr: dst, data: pkt))
  var saddr = dst
  <<ntop>>
  info "Prepare to send ULTRAVIOLET_OFF(pin: ", cast[uint16](ultraviolet_off.pin), ") to ", box, " @ ", address, ":", dst.sin_port
#+end_src
** 上行响应
#+begin_src nim :noweb-ref ultraviolet-off-confirm
  info "Confirm cmd type is ULTRAVIOLET_OFF"
  for taskstr in taskstrs:
    let task = try: parseJson(taskstr) except: nil
    if task != nil and task["command"].getStr() == "ultraviolet-off":
      <<remove-task>>
#+end_src

* CAMERA-ON
** 下行命令
#+begin_src nim :noweb-ref camera-on
  var camera_on: ref Parameter = new(Parameter)
  camera_on.pin = cast[int16](task["pin"].getInt())
  camera_on.zone = 8 * 60 * 60 * 1000
  camera_on.timestamp = cast[int64]((epochTime() * 1000).toInt())
  var pkt = camera_on.encode_as(CommandType.CAMERA_ON, uid)
  discard task_buffer.add((uid: uid, sockaddr: dst, data: pkt))
  var saddr = dst
  <<ntop>>
  info "Prepare to send CAMERA_ON(pin: ", cast[uint16](camera_on.pin), ") to ", box, " @ ", address, ":", dst.sin_port
#+end_src
** 上行响应
#+begin_src nim :noweb-ref camera-on-confirm
  info "Confirm cmd type is CAMERA_ON"
  for taskstr in taskstrs:
    let task = try: parseJson(taskstr) except: nil
    if task != nil and task["command"].getStr() == "camera-on":
      <<remove-task>>
#+end_src
* CAMERA-OFF
** 下行命令
#+begin_src nim :noweb-ref camera-off
  var camera_off: ref Parameter = new(Parameter)
  camera_off.pin = cast[int16](task["pin"].getInt())
  camera_off.zone = 8 * 60 * 60 * 1000
  camera_off.timestamp = cast[int64]((epochTime() * 1000).toInt())
  var pkt = camera_off.encode_as(CommandType.CAMERA_OFF, uid)
  discard task_buffer.add((uid: uid, sockaddr: dst, data: pkt))
  var saddr = dst
  <<ntop>>
  info "Prepare to send CAMERA_OFF(pin: ", cast[uint16](camera_off.pin), ") to ", box, " @ ", address, ":", dst.sin_port
#+end_src
** 上行响应
#+begin_src nim :noweb-ref camera-off-confirm
  info "Confirm cmd type is CAMERA_OFF"
  for taskstr in taskstrs:
    let task = try: parseJson(taskstr) except: nil
    if task != nil and task["command"].getStr() == "camera-off":
      <<remove-task>>
#+end_src

* CHARGER-STATUS
** 下行命令
#+begin_src nim :noweb-ref charger-status
  var param: ref Parameter = new(Parameter)
  param.pin = cast[int16](task["pin"].getInt())
  param.zone = 8 * 60 * 60 * 1000
  param.board = cast[int8](task["charger"].getInt())
  param.timestamp = cast[int64]((epochTime() * 1000).toInt())
  var pkt = param.encode_as(CommandType.CHARGER_STATUS, uid)
  discard task_buffer.add((uid: uid, sockaddr: dst, data: pkt))
  var saddr = dst
  <<ntop>>
  info "Prepare to send CHARGER_STATUS(pin: ", cast[uint16](param.pin), ") to ", box, " @ ", address, ":", dst.sin_port
#+end_src
** 上行响应
#+begin_src nim :noweb-ref charger-status-confirm
  info "Confirm cmd type is CHARGER_STATUS, pin: ", param.pin
  let
    charger = $param.board
    pluggedkey = "charger-plugged." & $uid & "." & $charger
    chargingkey = "charger-charging." & $uid & "." & $charger
    fullkey = "charger-full." & $uid & "." & $charger
    heatingkey = "charger-heating." & $uid & "." & $charger
    errnokey = "charger-errno." & $uid & "." & $charger
    temperaturekey = "charger-temperature." & $uid & "." & $charger
  await redis_client.multi()
  discard await redis_client.setEx(pluggedkey, 600, $param.charger_plugged)
  discard await redis_client.setEx(chargingkey, 600, $param.charger_charging)
  discard await redis_client.setEx(fullkey, 600, $param.charger_full)
  discard await redis_client.setEx(heatingkey, 600, $param.charger_heating)
  discard await redis_client.setEx(errnokey, 600, $param.errno)
  discard await redis_client.setEx(temperaturekey, 600, $param.temperature)
  for i in 0..len(param.batteries) - 1:
    var skey = "charger-battery." & $uid & "." & charger & "." & $i
    discard await redis_client.setEx(skey, 600, $param.batteries[i])
  discard await redis_client.exec()
  if param.pin != 0:
    for taskstr in taskstrs:
      let task = try: parseJson(taskstr) except: nil
      if task != nil and task["command"].getStr() == "charger-status" and task["pin"].getInt() == param.pin:
        <<remove-task>>
#+end_src
* CHARGER-CONFIG
** 下行命令
#+begin_src nim :noweb-ref charger-config
  var param: ref Parameter = new(Parameter)
  param.pin = cast[int16](task["pin"].getInt())
  param.zone = 8 * 60 * 60 * 1000
  param.board = cast[int8](task["charger"].getInt())
  param.timestamp = cast[int64]((epochTime() * 1000).toInt())
  var pkt = param.encode_as(CommandType.CHARGER_CONFIG, uid)
  discard task_buffer.add((uid: uid, sockaddr: dst, data: pkt))
  var saddr = dst
  <<ntop>>
  info "Prepare to send CHARGER_CONFIG(pin: ", cast[uint16](param.pin), ") to ", box, " @ ", address, ":", dst.sin_port
#+end_src
** 上行响应
#+begin_src nim :noweb-ref charger-config-confirm
  info "Confirm cmd type is CHARGER_CONFIG, pin: ", param.pin
  let
    charger = $param.board
    chargingkey = "charger-config.enable-charging." & $uid & "." & $charger
    heatingkey = "charger-config.enable-heating." & $uid & "." & $charger
  await redis_client.multi()
  await redis_client.setk(chargingkey, $param.enable_charging)
  await redis_client.setk(heatingkey, $param.enable_heating)
  discard await redis_client.exec()
  for taskstr in taskstrs:
    let task = try: parseJson(taskstr) except: nil
    if task != nil and task["command"].getStr() == "charger-config" and task["pin"].getInt() == param.pin:
      <<remove-task>>
#+end_src
* CONFIG-CHARGER
** 下行命令
#+begin_src nim :noweb-ref config-charger
  var param: ref Parameter = new(Parameter)
  param.pin = cast[int16](task["pin"].getInt())
  param.zone = 8 * 60 * 60 * 1000
  param.board = cast[int8](task["charger"].getInt())
  param.timestamp = cast[int64]((epochTime() * 1000).toInt())
  param.enable_charging = cast[int8](task["enable-charging"].getInt())
  param.enable_heating = cast[int8](task["enable-heating"].getInt())
  var pkt = param.encode_as(CommandType.CONFIG_CHARGER, uid)
  discard task_buffer.add((uid: uid, sockaddr: dst, data: pkt))
  var saddr = dst
  <<ntop>>
  info "Prepare to send CONFIG_CHARGER(enable-charging: ", $param.enable_charging, ", enable-heating: ", $param.enable_heating, ", pin: ", cast[uint16](param.pin), ") to ", box, " @ ", address, ":", dst.sin_port
#+end_src
** 上行响应
#+begin_src nim :noweb-ref config-charger-confirm
  info "Confirm cmd type is CONFIG_CHARGER, pin: ", param.pin
  let
    charger = $param.board
    chargingkey = "charger-config.enable-charging." & $uid & "." & $charger
    heatingkey = "charger-config.enable-heating." & $uid & "." & $charger
  await redis_client.multi()
  await redis_client.setk(chargingkey, $param.enable_charging)
  await redis_client.setk(heatingkey, $param.enable_heating)
  discard await redis_client.exec()
  for taskstr in taskstrs:
    let task = try: parseJson(taskstr) except: nil
    if task != nil and task["command"].getStr() == "config-charger" and task["pin"].getInt() == param.pin:
      <<remove-task>>
#+end_src
* PLAY
** 下行命令
#+begin_src nim :noweb-ref play
  var play: ref Parameter = new(Parameter)
  play.pin = cast[int16](task["pin"].getInt())
  play.audio = cast[int16](task["audio"].getInt())
  play.card_reader = cast[int8](task["speaker"].getInt())
  play.zone = 8 * 60 * 60 * 1000
  play.timestamp = cast[int64]((epochTime() * 1000).toInt())
  var pkt = play.encode_as(CommandType.PLAY, uid)
  discard task_buffer.add((uid: uid, sockaddr: dst, data: pkt))
  var saddr = dst
  <<ntop>>
  info "Prepare to send PLAY(speaker: ", play.card_reader, ", audio: ", play.audio, ", pin: ", cast[uint16](play.pin), ") to ", box, " @ ", address, ":", dst.sin_port
#+end_src
** 上行响应
#+begin_src nim :noweb-ref play-confirm
  info "Confirm cmd type is play, speaker: ", param.card_reader, ", audio: ", param.audio
  for taskstr in taskstrs:
    let task = try: parseJson(taskstr) except: nil
    if task != nil and task["command"].getStr() == "play" and task["speaker"].getInt() == param.card_reader and task["audio"].getInt() == param.audio and cast[int16](task["pin"].getInt()) == param.pin:
      <<remove-task>>
#+end_src
* VOLUME_UP
** 下行命令
#+begin_src nim :noweb-ref volume-up
  var param: ref Parameter = new(Parameter)
  param.pin = cast[int16](task["pin"].getInt())
  param.card_reader = cast[int8](task["speaker"].getInt())
  param.zone = 8 * 60 * 60 * 1000
  param.timestamp = cast[int64]((epochTime() * 1000).toInt())
  var pkt = param.encode_as(CommandType.VOLUME_UP, uid)
  discard task_buffer.add((uid: uid, sockaddr: dst, data: pkt))
  var saddr = dst
  <<ntop>>
  info "Prepare to send VOLUME_UP(speaker: ", param.card_reader, ", pin: ", cast[uint16](param.pin), ") to ", box, " @ ", address, ":", dst.sin_port
#+end_src
** 上行响应
#+begin_src nim :noweb-ref volume-up-confirm
  info "Confirm cmd type is volume-up, speaker: ", param.card_reader
  for taskstr in taskstrs:
    let task = try: parseJson(taskstr) except: nil
    if task != nil and task["command"].getStr() == "volume-up" and task["speaker"].getInt() == param.card_reader and cast[int16](task["pin"].getInt()) == param.pin:
      <<remove-task>>
#+end_src
* VOLUME_DOWN
** 下行命令
#+begin_src nim :noweb-ref volume-down
  var param: ref Parameter = new(Parameter)
  param.pin = cast[int16](task["pin"].getInt())
  param.card_reader = cast[int8](task["speaker"].getInt())
  param.zone = 8 * 60 * 60 * 1000
  param.timestamp = cast[int64]((epochTime() * 1000).toInt())
  var pkt = param.encode_as(CommandType.VOLUME_DOWN, uid)
  discard task_buffer.add((uid: uid, sockaddr: dst, data: pkt))
  var saddr = dst
  <<ntop>>
  info "Prepare to send VOLUME_DOWN(speaker: ", param.card_reader, ", pin: ", cast[uint16](param.pin), ") to ", box, " @ ", address, ":", dst.sin_port
#+end_src
** 上行响应
#+begin_src nim :noweb-ref volume-down-confirm
  info "Confirm cmd type is volume-down, speaker: ", param.card_reader
  for taskstr in taskstrs:
    let task = try: parseJson(taskstr) except: nil
    if task != nil and task["command"].getStr() == "volume-down" and task["speaker"].getInt() == param.card_reader and cast[int16](task["pin"].getInt()) == param.pin:
      <<remove-task>>
#+end_src
* VOLUME
** 下行命令
#+begin_src nim :noweb-ref volume
  var param: ref Parameter = new(Parameter)
  param.pin = cast[int16](task["pin"].getInt())
  param.volume = cast[int8](task["volume"].getInt())
  param.card_reader = cast[int8](task["speaker"].getInt())
  param.zone = 8 * 60 * 60 * 1000
  param.timestamp = cast[int64]((epochTime() * 1000).toInt())
  var pkt = param.encode_as(CommandType.VOLUME, uid)
  discard task_buffer.add((uid: uid, sockaddr: dst, data: pkt))
  var saddr = dst
  <<ntop>>
  info "Prepare to send VOLUME_DOWN(speaker: ", param.card_reader, ", pin: ", cast[uint16](param.pin), ") to ", box, " @ ", address, ":", dst.sin_port
#+end_src
** 上行响应
#+begin_src nim :noweb-ref volume-confirm
  info "Confirm cmd type is volume, speaker: ", param.card_reader, ", volume:", param.volume
  for taskstr in taskstrs:
    let task = try: parseJson(taskstr) except: nil
    if task != nil and task["command"].getStr() == "volume" and task["speaker"].getInt() == param.card_reader and task["volume"].getInt() == param.volume and cast[int16](task["pin"].getInt()) == param.pin:
      <<remove-task>>
#+end_src
* CONFIG_NETWORK
** 下行命令
#+begin_src nim :noweb-ref config-network
  var param: ref Parameter = new(Parameter)
  param.pin = cast[int16](task["pin"].getInt())
  param.network_heart_rate = cast[int32](task["network-heart-rate"].getInt())
  param.network_timeout = cast[int32](task["network-timeout"].getInt())
  param.zone = 8 * 60 * 60 * 1000
  param.timestamp = cast[int64]((epochTime() * 1000).toInt())
  var pkt = param.encode_as(CommandType.CONFIG_NETWORK, uid)
  discard task_buffer.add((uid: uid, sockaddr: dst, data: pkt))
  var saddr = dst
  <<ntop>>
  info "Prepare to send CONFIG_NETWORK(network-heart-rate: ", param.network_heart_rate, ", network-timeout: ", param.network_timeout, ", pin: ", cast[uint16](param.pin), ") to ", box, " @ ", address, ":", dst.sin_port
#+end_src
** 上行响应
#+begin_src nim :noweb-ref config-network-confirm
  info "Confirm cmd type is config-network-confirm"
  for taskstr in taskstrs:
    let task = try: parseJson(taskstr) except: nil
    if task != nil and task["command"].getStr() == "config-network" and cast[int16](task["pin"].getInt()) == param.pin:
      <<remove-task>>
#+end_src
* EGG-LOCK-ON
** 下行命令
#+begin_src nim :noweb-ref egg-lock-on
  var cmd: ref Parameter = new(Parameter)
  cmd.pin = cast[int16](task["pin"].getInt())
  cmd.lock = cast[int8](task["cabin"].getInt())
  cmd.board = cast[int8](task["egg"].getInt())
  cmd.zone = 8 * 60 * 60 * 1000
  cmd.timestamp = cast[int64]((epochTime() * 1000).toInt())
  var pkt = cmd.encode_as(CommandType.EGG_LOCK_ON, uid)
  discard task_buffer.add((uid: uid, sockaddr: dst, data: pkt))
  var saddr = dst
  <<ntop>>
  info "Prepare to send EGG_LOCK_ON(egg: ", cmd.board, ", cabin: ", cmd.lock, ", pin: ", cast[uint16](cmd.pin), ") to ", box, " @ ", address, ":", dst.sin_port
#+end_src
** 上行响应
#+begin_src nim :noweb-ref egg-lock-on-confirm
  info "Confirm cmd type is egg-lock-on, egg: ", param.board, ", cabin: ", param.lock
  discard await redis_client.setEx("egg-lock-on-ack." & $uid & "." & $cast[uint16](param.pin), 30, $param.timestamp)
  for taskstr in taskstrs:
    let task = try: parseJson(taskstr) except: nil
    if task != nil and task["command"].getStr() == "egg-lock-on" and task["egg"].getInt() == param.board and task["cabin"].getInt() == param.lock and cast[int16](task["pin"].getInt()) == param.pin:
      <<remove-task>>
#+end_src
* EGG-LOCK-OFF
** 下行命令
#+begin_src nim :noweb-ref egg-lock-off
  var cmd: ref Parameter = new(Parameter)
  cmd.pin = cast[int16](task["pin"].getInt())
  cmd.lock = cast[int8](task["cabin"].getInt())
  cmd.board = cast[int8](task["egg"].getInt())
  cmd.zone = 8 * 60 * 60 * 1000
  cmd.timestamp = cast[int64]((epochTime() * 1000).toInt())
  var pkt = cmd.encode_as(CommandType.EGG_LOCK_OFF, uid)
  discard task_buffer.add((uid: uid, sockaddr: dst, data: pkt))
  var saddr = dst
  <<ntop>>
  info "Prepare to send EGG_LOCK_OFF(egg: ", cmd.board, ", cabin: ", cmd.lock, ", pin: ", cast[uint16](cmd.pin), ") to ", box, " @ ", address, ":", dst.sin_port
#+end_src
** 上行响应
#+begin_src nim :noweb-ref egg-lock-off-confirm
  info "Confirm cmd type is egg-lock-off, egg: ", param.board, ", cabin: ", param.lock
  discard await redis_client.setEx("egg-lock-off-ack." & $uid & "." & $cast[uint16](param.pin), 30, $param.timestamp)
  let taskstrs: seq[string] = await redis_client.lrange(taskkey, 0, -1)
  for taskstr in taskstrs:
    let task = try: parseJson(taskstr) except: nil
    if task != nil and task["command"].getStr() == "egg-lock-off" and task["egg"].getInt() == param.board and task["cabin"].getInt() == param.lock and cast[int16](task["pin"].getInt()) == param.pin:
      <<remove-task>>
#+end_src
* EGG-PLAY
** 下行命令
#+begin_src nim :noweb-ref egg-play
  var cmd: ref Parameter = new(Parameter)
  cmd.pin = cast[int16](task["pin"].getInt())
  cmd.audio = cast[int16](task["audio"].getInt())
  cmd.board = cast[int8](task["egg"].getInt())
  cmd.zone = 8 * 60 * 60 * 1000
  cmd.timestamp = cast[int64]((epochTime() * 1000).toInt())
  var pkt = cmd.encode_as(CommandType.EGG_PLAY, uid)
  discard task_buffer.add((uid: uid, sockaddr: dst, data: pkt))
  var saddr = dst
  <<ntop>>
  info "Prepare to send EGG_PLAY(egg: ", cmd.board, ", audio: ", cmd.audio, ", pin: ", cast[uint16](cmd.pin), ") to ", box, " @ ", address, ":", dst.sin_port
#+end_src
** 上行响应
#+begin_src nim :noweb-ref egg-play-confirm
  info "Confirm cmd type is egg-play, egg: ", param.board, ", audio: ", param.audio
  discard await redis_client.setEx("egg-play-ack." & $uid & "." & $cast[uint16](param.pin), 30, $param.timestamp)
  for taskstr in taskstrs:
    let task = try: parseJson(taskstr) except: nil
    if task != nil and task["command"].getStr() == "egg-play" and task["egg"].getInt() == param.board and task["audio"].getInt() == param.audio and cast[int16](task["pin"].getInt()) == param.pin:
      <<remove-task>>
#+end_src
* EGG-GPIO
** 下行命令
#+begin_src nim :noweb-ref egg-gpio
  var cmd: ref Parameter = new(Parameter)
  cmd.pin = cast[int16](task["pin"].getInt())
  cmd.gpio = cast[int8](task["gpio"].getInt())
  cmd.board = cast[int8](task["egg"].getInt())
  cmd.zone = 8 * 60 * 60 * 1000
  cmd.timestamp = cast[int64]((epochTime() * 1000).toInt())
  var pkt = cmd.encode_as(CommandType.EGG_GPIO, uid)
  discard task_buffer.add((uid: uid, sockaddr: dst, data: pkt))
  var saddr = dst
  <<ntop>>
  info "Prepare to send EGG_GPIO(egg: ", cmd.board, ", gpio: ", cmd.gpio, ", pin: ", cast[uint16](cmd.pin), ") to ", box, " @ ", address, ":", dst.sin_port
#+end_src
** 上行响应
#+begin_src nim :noweb-ref egg-gpio-confirm
  info "Confirm cmd type is egg-gpio, egg: ", param.board, ", gpio: ", param.gpio
  discard await redis_client.setEx("egg-gpio-ack." & $uid & "." & $cast[uint16](param.pin), 30, $param.timestamp)
  for taskstr in taskstrs:
    let task = try: parseJson(taskstr) except: nil
    if task != nil and task["command"].getStr() == "egg-gpio" and task["egg"].getInt() == param.board and task["gpio"].getInt() == param.gpio and cast[int16](task["pin"].getInt()) == param.pin:
      <<remove-task>>
#+end_src
* EGG-FALLEN
扭蛋机检测到落蛋事件后，上报给服务端。
** 上行命令
#+begin_src nim :noweb-ref egg-fallen
  let
    uid = data.uid
    param = data.parameter
    sn = param.sn
    pin = param.pin
    now = cast[int]((epochTime() * 1000).toInt() shr 10)
    timestamp = cast[int](param.timestamp shr 10)
    expires_in = if now >= timestamp: 3600 else: timestamp - now
  <<save-connections>>

  info "EGG-FALLEN, egg: ", param.board, ", cabin: ", param.lock
  <<egg-fallen-confirm>>
#+end_src
** 下行响应
#+begin_src nim :noweb-ref egg-fallen-confirm
  var confirm: ref Parameter = new(Parameter)
  confirm.sn = sn
  confirm.pin = pin
  confirm.version = 0
  confirm.cmd_type = 30 # CommandType.EGG_FALLEN
  confirm.zone = 8 * 60 * 60 * 1000
  confirm.timestamp = cast[int64]((epochTime() * 1000).toInt())
  var pkt = confirm.encode_as(CommandType.CONFIRM, uid)
  discard task_buffer.add((uid: uid, sockaddr: saddr, data: pkt))
  info "Prepare to send CONFIRM of EGG-FALLEN to ", box, " @ ", address, ":", saddr.sin_port
#+end_src

* EGG-VOLUME
** 下行命令
#+begin_src nim :noweb-ref egg-volume
  var cmd: ref Parameter = new(Parameter)
  cmd.pin = cast[int16](task["pin"].getInt())
  cmd.volume = cast[int8](task["volume"].getInt())
  cmd.board = cast[int8](task["egg"].getInt())
  cmd.zone = 8 * 60 * 60 * 1000
  cmd.timestamp = cast[int64]((epochTime() * 1000).toInt())
  var pkt = cmd.encode_as(CommandType.EGG_VOLUME, uid)
  discard task_buffer.add((uid: uid, sockaddr: dst, data: pkt))
  var saddr = dst
  <<ntop>>
  info "Prepare to send EGG_VOLUME(egg: ", cmd.board, ", volume: ", cmd.volume, ", pin: ", cast[uint16](cmd.pin), ") to ", box, " @ ", address, ":", dst.sin_port
#+end_src
** 上行响应
#+begin_src nim :noweb-ref egg-volume-confirm
  info "Confirm cmd type is egg-volume, egg: ", param.board, ", volume: ", param.volume
  discard await redis_client.setEx("egg-volume-ack." & $uid & "." & $cast[uint16](param.pin), 30, $param.timestamp)
  for taskstr in taskstrs:
    let task = try: parseJson(taskstr) except: nil
    if task != nil and task["command"].getStr() == "egg-volume" and task["egg"].getInt() == param.board and task["volume"].getInt() == param.volume and cast[int16](task["pin"].getInt()) == param.pin:
      <<remove-task>>
#+end_src
* EGG-TIMETOU
扭蛋机检测到超时事件后，上报给服务端。
** 上行命令
#+begin_src nim :noweb-ref egg-timeout
  let
    uid = data.uid
    param = data.parameter
    sn = param.sn
    pin = param.pin
    now = cast[int]((epochTime() * 1000).toInt() shr 10)
    timestamp = cast[int](param.timestamp shr 10)
    expires_in = if now >= timestamp: 3600 else: timestamp - now
  <<save-connections>>

  info "EGG-TIMETOU, egg: ", param.board, ", cabin: ", param.lock
  <<egg-timeout-confirm>>
#+end_src
** 下行响应
#+begin_src nim :noweb-ref egg-timeout-confirm
  var confirm: ref Parameter = new(Parameter)
  confirm.sn = sn
  confirm.pin = pin
  confirm.version = 0
  confirm.cmd_type = 32 # CommandType.EGG_TIMETOUT
  confirm.zone = 8 * 60 * 60 * 1000
  confirm.timestamp = cast[int64]((epochTime() * 1000).toInt())
  var pkt = confirm.encode_as(CommandType.CONFIRM, uid)
  discard task_buffer.add((uid: uid, sockaddr: saddr, data: pkt))
  info "Prepare to send CONFIRM of EGG-TIMEOUT to ", box, " @ ", address, ":", saddr.sin_port
#+end_src

* EGG-QUERY
** 下行命令
#+begin_src nim :noweb-ref egg-query
  var cmd: ref Parameter = new(Parameter)
  cmd.pin = cast[int16](task["pin"].getInt())
  cmd.lock = cast[int8](task["cabin"].getInt())
  cmd.board = cast[int8](task["egg"].getInt())
  cmd.zone = 8 * 60 * 60 * 1000
  cmd.timestamp = cast[int64]((epochTime() * 1000).toInt())
  var pkt = cmd.encode_as(CommandType.EGG_QUERY, uid)
  discard task_buffer.add((uid: uid, sockaddr: dst, data: pkt))
  var saddr = dst
  <<ntop>>
  info "Prepare to send EGG_QUERY(egg: ", cmd.board, ", cabin: ", cmd.lock, ", pin: ", cast[uint16](cmd.pin), ") to ", box, " @ ", address, ":", dst.sin_port
#+end_src
** 上行响应
#+begin_src nim :noweb-ref egg-query-confirm
info "Confirm cmd type is egg-query, egg: ", param.board, ", cabin: ", param.lock
  await redis_client.multi()
  discard await redis_client.setEx("egg-query-ack." & $uid & "." & $cast[uint16](param.pin), 30, $param.timestamp)
  discard await redis_client.setEx("egg-busy." & $uid & "." & $param.board & "." & $param.lock, 30, $param.busy)
  discard await redis_client.exec()
  for taskstr in taskstrs:
    let task = try: parseJson(taskstr) except: nil
    if task != nil and task["command"].getStr() == "egg-query" and task["egg"].getInt() == param.board and task["cabin"].getInt() == param.lock and cast[int16](task["pin"].getInt()) == param.pin:
      <<remove-task>>
#+end_src
* REBOOT
** 下行命令
#+begin_src nim :noweb-ref reboot
  var param: ref Parameter = new(Parameter)
  param.pin = cast[int16](task["pin"].getInt())
  var pkt = param.encode_as(CommandType.REBOOT, uid)
  discard task_buffer.add((uid: uid, sockaddr: dst, data: pkt))
  var saddr = dst
  <<ntop>>
  info "Prepare to send REBOOT(pin: ", cast[uint16](param.pin), ") to ", box, " @ ", address, ":", dst.sin_port
#+end_src
** 上行响应
#+begin_src nim :noweb-ref reboot-confirm
  info "Confirm cmd type is reboot-confirm"
  for taskstr in taskstrs:
    let task = try: parseJson(taskstr) except: nil
    if task != nil and task["command"].getStr() == "reboot" and cast[int16](task["pin"].getInt()) == param.pin:
      <<remove-task>>
#+end_src
* 数据封包
#+begin_src nim :exports code :noweb yes :mkdirp yes :tangle /dev/shm/box-service/src/box_servicepkg/box_packer.nim
  import parameter, zeropack
  import hashes, logging, sequtils, strutils
  type
    CommandType* {.pure.} = enum
      UNKNOWN = 0, PING = 1, PONG = 2, CONFIRM = 3, LOCK_OFF = 4, LOCKS_OFF = 5, LOCK_STATUS = 6, LOCK_DETECT = 7, LOCK_STATUS_DETECT = 8, CHARGER_STATUS = 9, LIGHT_ON = 10, LIGHT_OFF = 11, FAN_ON = 12, FAN_OFF = 13, ULTRAVIOLET_ON = 14, ULTRAVIOLET_OFF = 15, CAMERA_ON = 16, CAMERA_OFF = 17, LOCK_DATA = 18, PLAY = 19, VOLUME_UP = 20, VOLUME_DOWN = 21, CONFIG_NETWORK = 22, VOLUME = 23, CHARGER_CONFIG = 24, CONFIG_CHARGER = 25, EGG_LOCK_ON = 26, EGG_LOCK_OFF = 27, EGG_PLAY = 28, EGG_GPIO = 29, EGG_FALLEN = 30, EGG_VOLUME = 31, EGG_TIMEOUT = 32, EGG_QUERY = 33, REBOOT = 63
    UID* = array[0..11, byte]
    PackResultObject* = object of RootObj
      uid*: UID
      cmd_type*: CommandType
      parameter*: ref Parameter
    PackResult* = ref PackResultObject

  const version: int = 0
  const CRC8_KEY: uint8 = 0x07

  proc `$`*(uid: UID): string =
    return uid.mapIt(toHex(cast[BiggestInt](it), 2)).join("-")

  proc hash*(x: UID): Hash =
    let
      byte0 = x[0] xor x[4] xor x[8]
      byte1 = x[1] xor x[5] xor x[9]
      byte2 = x[2] xor x[6] xor x[10]
      byte3 = x[3] xor x[7] xor x[11]
    result = (cast[int](byte0) shl 24) + (cast[int](byte1) shl 16) + (cast[int](byte2) shl 8) + cast[int](byte3)

  proc parseUID*(uidstr: string): UID =
    let bytes = uidstr.split('-').mapIt(cast[byte](parseHexInt(it)))
    result[0] = bytes[0]
    result[1] = bytes[1]
    result[2] = bytes[2]
    result[3] = bytes[3]
    result[4] = bytes[4]
    result[5] = bytes[5]
    result[6] = bytes[6]
    result[7] = bytes[7]
    result[8] = bytes[8]
    result[9] = bytes[9]
    result[10] = bytes[10]
    result[11] = bytes[11]

  proc crc8(buf: seq[byte], offset: int, len: int): uint8 =
    var bptr = offset
    let stop = offset + len
    while bptr != stop:
      var i: uint8 = 0x80
      while i != 0:
        if (result and 0x80) != 0:
          result = result shl 1
          result = result xor CRC8_KEY
        else:
          result = result shl 1
        if (buf[bptr] and i) != 0:
          result = result xor CRC8_KEY
        i = i shr 1
      bptr += 1

  proc encode(payload: seq[byte], cmd_type: CommandType, uid: UID): seq[byte] =
    let
      payload_size = len(payload)
      header_size = 1 + 1 + 1 + 12
      size: int = header_size + payload_size
      uid_start = 3
    var buf: seq[byte] = newSeq[byte](size)
    buf[0] = cast[byte](size and 0xFF)
    buf[2] = cast[byte](ord(cmd_type))
    for i in 0..11:
      buf[uid_start + i] = uid[i]
    var payload_start = header_size
    for i in 0..(payload_size - 1):
      buf[payload_start + i] = payload[i]
    buf[1] = crc8(buf, 2, payload_size + header_size - 2)
    return buf

  proc encode_as*(parameter: ref Parameter, cmd_type: CommandType, uid: UID): seq[byte] =
    let size: int = parameter.calculate_size()
    var buf: seq[byte] = newSeq[byte](size)
    discard parameter.encode_into(buf, 0)
    let zipped_buf = zeropack(buf)
    return encode(zipped_buf, cmd_type, uid)

  proc decode*(buf: seq[byte], offset: int, length: int): PackResult =
    let
      header_size = 1 + 1 + 1 + 12
      packed_size = cast[int](buf[offset])
    if length != packed_size:
      warn "Length is invalid, got ", $length, " but need ", packed_size
      #echo hexdump(buf, length)
      return nil
    let checksum: uint8 = crc8(buf, offset + 2, length - 2)
    if checksum != buf[offset + 1]:
      warn "Checksum is invalid, got ", buf[offset + 1], " but should be ", checksum, "\n"
      return nil
    var uid: UID
    for i in 0..11:
      uid[i] = buf[offset + 1 + 1 + 1 + i]
    let unzipped: seq[byte] = unzeropack(buf, offset + header_size, length - header_size)
    let cmdtype = buf[offset + 1 + 1]
    if cmdtype < 34 or cmdtype == 63:
      result = PackResult(cmd_type: CommandType(cmdtype), uid: uid, parameter: parameter.decode_from(unzipped, 0))
    else:
      warn "Command type is invalid\n"
      return nil
#+end_src
* 支援方法
** 保存连接

将设备的地址和对应的 Socket Address 保存到 device_connections 中，以后
可以根据此地址，主动给设备发送数据。同时把设备的地址加入到当前活跃设备
集合中。每个连接至少可以维持 60 秒。

首次连接时，可以把固件的版本信息按设备配置拆解后，保存到缓存中。如果是
不支持版本信息的老固件，则默认锁控为 DGZL，其它信息不设置。

#+begin_src nim :noweb-ref save-connections
  if device_connections.has_key(uid):
    let pair = device_connections[uid]
    device_connections[uid] = (name: pair[0], expires_at: epochTime().toInt() + 60, sockaddr: saddr)
  else:
    let fireware = data.parameter.fireware_version
    if fireware != 0:
      let
        main_version = cast[uint8](fireware and 0xFF)
        sub_version = cast[uint8]((fireware shr 8) and 0xFF)
        network = cast[uint8]((fireware shr 16) and 0x0F)
        locksystem = cast[uint8]((fireware shr 20) and 0x0F)
      await redis_client.multi()
      case network:
        of 1:
          await redis_client.setk("network." & $uid, "SIM800")
        of 2:
          await redis_client.setk("network." & $uid, "ESP8266")
        of 4:
          await redis_client.setk("network." & $uid, "EC20")
        else:
          discard
      case locksystem:
        of 1:
          await redis_client.setk("locksystem." & $uid, "DGZL")
        of 2:
          await redis_client.setk("locksystem." & $uid, "FC")
        else:
          discard
      discard await redis_client.exec()
    else:
      await redis_client.multi()
      discard await redis_client.del(@["network." & $uid])
      await redis_client.setk("locksystem." & $uid, "DGZL")
      discard await redis_client.exec()
    let name = await redis_client.hget("boxes", $uid)
    device_connections[uid] = (name: if name == redisNil: $uid else: $uid & "(" & name & ")", expires_at: epochTime().toInt() + 60, sockaddr: saddr)
  let
    t = getTime()
    activated_key = "box.activated." & getDateStr() & "." & $local(t).hour.format("02d") & "." & $local(t).minute.format("02d")
  discard await redis_client.sAdd(activated_key, $uid)
#+end_src

** 保存 NETWORK 状态

每一个从设备发送到 box service 的命令都携带了设备的 NETWORK 状态信息。需
要将这些信息保存在缓存中，供数据挖掘程序使用。

#+begin_src nim :noweb-ref save-network-status
  let
    rssi_key = "rssi." & $uid & "." & getDateStr() & "." & $local(t).hour.format("02d") & "." & $local(t).minute.format("02d")
    ping_key = "ping." & $uid & "." & getDateStr() & "." & $local(t).hour.format("02d") & "." & $local(t).minute.format("02d")
    reset_key = "reset." & $uid & "." & getDateStr() & "." & $local(t).hour.format("02d") & "." & $local(t).minute.format("02d")
    rssi = param.rssi
    ber = param.ber
    reply_time = if param.reply_time == 600: -1 else: param.reply_time
    ttl = if param.ttl == 255: -1 else: param.ttl
    network_reset = param.network_reset
    network_shutdown = param.network_shutdown
  await redis_client.multi()
  if rssi != 0 or ber != 0:
    await redis_client.setk(rssi_key, $rssi & "," & $ber)
  if reply_time != 0 or ttl != 0:
    await redis_client.setk(ping_key, $reply_time & "," & $ttl)
  if network_shutdown != 0 or network_reset != 0:
    await redis_client.setk(reset_key, $network_shutdown & "," & $network_reset)
  discard await redis_client.exec()
#+end_src

时间 t 由前一个代码块提供。

** hexdump

#+begin_src nim :noweb-ref hexdump
  proc hexdump(buf: seq[byte], size: int): string =
    var output = ""
    for i in 0..(size - 1):
      output.add("$1 " % (toHex(buf[i])))
      if i mod 8 == 7:
        output.add("\n")
    return output
#+end_src
** 转换IP地址为字符串

#+begin_src nim :noweb-ref ntop
  discard inet_ntop(posix.AF_INET, cast[pointer](addr saddr.sin_addr), cstring(address), len(address).int32)
  address = address.strip(chars = {'\0'})
#+end_src

** 从缓存中删除已完成任务

#+begin_src nim :noweb-ref remove-task
  discard await redis_client.lrem(taskkey, taskstr, 1)
  <<update-status-to-sent>>
  info "Remove from redis ", taskstr
#+end_src
** 生成 PIN

   PIN 为当前时间戳除 10 与 8192 取模，外加设备编号的结果，用于保证每10秒内，对同一个设备只执行一次命令。
| no | dev         |
|----+-------------|
|  0 | light       |
|  1 | fan         |
|  2 | ultraviolet |
|  3 | camera      |

#+begin_src nim :noweb-ref generate-pin
  proc generate_pin(dev: int): int =
    result = cast[int](cast[int64](epochTime().toInt() shr 3) and 8191) or (dev shl 13)
#+end_src
** 检查 base64 编码
服务从设备上收到的数据是用 base64 编码处理过的。如果收到的数据包不是
base64 编码，则后续的处理会导致服务崩溃。因此必须判断接收到数据包是否
是 base64 编码。检查的方法很简单，对收到的数据包中的每个字节，检查是否
在 "A-Z", "a-z", "0-9", "+/=" 范围内。

#+begin_src nim :noweb-ref check-base64
  proc check_base64(buf: ref array[1024, byte], len: int): bool =
    result = true
    for i in 0..len:
      let b = buf[i]
      if not ((0x2E'u8 < b and b < 0x3A'u8) or (0x40'u8 < b and b < 0x5b'u8) or (0x60'u8 < b and b < 0x7b'u8) or (b == 0x2B)):
        result = false
        break
#+end_src
