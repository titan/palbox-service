* 基本框架

Box service 是设备连接到系统的通道。设备通过 box service 上报数据；管理系统通过
box service 给设备发送命令。服务采用异步方式编写，启动后侦听 UDP/5008 端口，处理
收到的请求，并把响应返回给请求的设备；或者把任务数据下发给设备。

Box service 依赖 redis 来对设备下发命令。redis 用 AsyncRedis 来访问， AsyncRedis
是 async 的，要求能做到断开后还能重新连接。为了能做到这一点，代码中采用
redis_connected 这个 bool 型变量。一旦发现连接断开，就设置对应的变量，后续程序发
现连接断开，会自动重新连接。

#+begin_src nim :exports code :noweb yes :mkdirp yes :tangle /dev/shm/box-service/src/box_service.nim
  import asyncdispatch, asyncnet, base64, json, logging, nativesockets, posix, redis, ringbuffer, sequtils, strutils, tables, times
  import box_servicepkg/box_packer, box_servicepkg/parameter

  <<hexdump>>

  type
    Task = tuple[sockaddr: Sockaddr_in, data: seq[byte]]

  var device_connections: Table[box_packer.UID, tuple[expires_at: int, sockaddr: Sockaddr_in]] = initTable[box_packer.UID, tuple[expires_at: int, sockaddr: Sockaddr_in]]()
  var task_buffer: RingBuffer[Task] = newRingBuffer[Task](bitsize = 10)
  var L = newConsoleLogger(fmtStr = "$levelid [$datetime] : ")
  addHandler(L)

  proc prepareAddress(intaddr: uint32, intport: uint16): ptr Sockaddr_in =
    result = cast[ptr Sockaddr_in](alloc0(sizeof(Sockaddr_in)))
    result.sin_family = toInt(nativesockets.AF_INET)
    result.sin_port = nativesockets.htons(intport)
    result.sin_addr.s_addr = nativesockets.htonl(intaddr)


#+end_src

** send

发送任务数据到设备。发送任务检查 task_buffer 中的发送数据，有任务就发送到对应的
设备，没有就休眠 1 秒。

#+begin_src nim :exports code :noweb yes :mkdirp yes :tangle /dev/shm/box-service/src/box_service.nim
  proc send_always(sock: AsyncFD) {.async.} =
    var
      sndbuf: ref array[1024, byte] = new(array[1024, byte])
      address = newString(128)
      slen = sizeof(Sockaddr_in).SockLen
    while true:
      if len(task_buffer) > 0'u32:
        let task = pop(task_buffer)
        zeroMem(cast[pointer](sndbuf), 1024)
        let encoded = base64.encode[byte](task.data, lineLen = 1024)
        for i in 0..(len(encoded) - 1):
          sndbuf[i] = ord(encoded[i])
        var dst = task.sockaddr
        await sendTo(socket = sock, data = cast[pointer](sndbuf), size = len(encoded), saddr = cast[ptr SockAddr](addr(dst)), saddrLen = slen)
        discard inet_ntop(posix.AF_INET, cast[pointer](addr dst.sin_addr), cstring(address), len(address).int32)
        info "Send ", len(encoded), " byte(s) to ", address, ": ", encoded
        flushFile(stdout)
        #info hexdump(task.data, len(task.data))
      else:
        await sleepAsync(1000)
#+end_src

** receive

从设备接收数据。

#+begin_src nim :exports code :noweb yes :mkdirp yes :tangle /dev/shm/box-service/src/box_service.nim
  proc receive_always(sock: AsyncFD) {.async.} =
    var
      rcvbuf: ref array[1024, byte] = new(array[1024, byte])
      address = newString(128)
      slen = sizeof(Sockaddr_in).SockLen
      redis_client: AsyncRedis
      redis_connected: bool = false
    while true:
      block mainloop:
        if not redis_connected:
          let redis_result = openAsync(host = "localhost")
          yield redis_result
          if redis_result.failed():
            redis_connected = false
          else:
            redis_connected = true
            redis_client = redis_result.read()
        zeroMem(cast[pointer](rcvbuf), 1024)
        var saddr = Sockaddr_in()
        zeroMem(cast[pointer](addr(saddr)), sizeof(Sockaddr_in))
        let blen = await sock.recvFromInto(cast[pointer](rcvbuf), 1024, cast[ptr SockAddr](addr(saddr)), addr(slen))
        discard inet_ntop(posix.AF_INET, cast[pointer](addr saddr.sin_addr), cstring(address), len(address).int32)
        var received = ""
        for i in 0..blen - 1:
          received &= chr(rcvbuf[i])
        info "Received ", blen, " bytes: ", received
        flushFile(stdout)
        let rcvd: string = base64.decode($cast[cstring](rcvbuf))
        for i in 0..len(rcvd) - 1:
          rcvbuf[i] = ord(rcvd[i])
        # info hexdump(@(rcvbuf[]), len(rcvd))
        var data: PackResult = box_packer.decode(@(rcvbuf[]), 0, len(rcvd))
        if data != nil:
          case data.cmd_type:
            of CommandType.PING:
              info "Receive PING from ", address
              flushFile(stdout)
              <<ping>>
            of CommandType.CONFIRM:
              info "Receive CONFIRM from ", address
              flushFile(stdout)
              <<confirm>>
            of CommandType.LOCK_DATA:
              info "Receive LOCK_DATA from ", address
              flushFile(stdout)
              <<lock-data>>
            else:
              info "Receive UNKNOWN from ", address
              flushFile(stdout)
        else:
          info "Receive invalid packet from ", address
          flushFile(stdout)
#+end_src

** check task

检查任务队列。第一步，从已经建立连接的设备任务队列中获取任务，如果任务过期了，就
不发送任务；否则，就根据任务的类型将任务填充到 task_buffer 中。

#+begin_src nim :exports code :noweb yes :mkdirp yes :tangle /dev/shm/box-service/src/box_service.nim
  proc check_always() {.async.} =
    var
      redis_client: AsyncRedis
      redis_connected: bool = false
      address = newString(128)
    while true:
      if not redis_connected:
        let redis_result = openAsync(host = "localhost")
        yield redis_result
        if redis_result.failed():
          redis_connected = false
        else:
          redis_connected = true
          redis_client = redis_result.read()
      let keys_result = redis_client.keys("tasks.*")
      yield keys_result
      if keys_result.failed():
        redis_connected = false
        await sleepAsync(1000)
      else:
        let taskkeys = keys_result.read()
        for taskkey in taskkeys:
          if len(taskkey) != 41:
            warn "Invalid taskkey ", taskkey
            flushFile(stdout)
            continue
          let taskstr = await redis_client.lIndex(taskkey, -1)
          if taskstr == redisNil:
            warn "Got nothing in task queue"
            flushFile(stdout)
            continue
          else:
            let task = try: parseJson(taskstr)
                       except: nil
            if task == nil or task["expires-at"].getNum() < epochTime().toInt():
              let lrem_result = await redis_client.lrem(taskkey, taskstr, 1)
              if lrem_result == 0:
                warn "Cannot remove expired task ", taskstr, " from ", taskkey
                flushFile(stdout)
              else:
                info "Remove expired task ", taskstr, " from ", taskkey
                flushFile(stdout)
            else:
              let uid = box_packer.parseUID(taskkey[6..len(taskkey) - 1])
              if not device_connections.contains(uid):
                warn "Connection for uid ", uid, " is missing"
                flushFile(stdout)
                continue
              let
                expired_connection: tuple[expires_at: int, sockaddr: Sockaddr_in] = device_connections[uid]
                (expires_at, dst) = expired_connection
              if expires_at < epochTime().toInt():
                warn "Connection of uid ", uid, " is expired"
                flushFile(stdout)
                device_connections.del(uid)
              else:
                info "Found task for ", $uid
                flushFile(stdout)
                case task["command"].getStr():
                  of "lock-off":
                    <<lock-off>>
                  of "locks-off":
                    <<locks-off>>
                  of "lock-status":
                    <<lock-status>>
                  of "lock-detect":
                    <<lock-detect>>
                  of "lock-status-detect":
                    <<lock-status-detect>>
                  of "light-on":
                    <<light-on>>
                  of "light-off":
                    <<light-off>>
                  of "fan-on":
                    <<fan-on>>
                  of "fan-off":
                    <<fan-off>>
                  of "ultraviolet-on":
                    <<ultraviolet-on>>
                  of "ultraviolet-off":
                    <<ultraviolet-off>>
                  of "camera-on":
                    <<camera-on>>
                  of "camera-off":
                    <<camera-off>>
                  of "charger-status":
                    <<charger-status>>
                  else:
                    let rpop_result = await redis_client.rpop(taskkey)
                    if rpop_result == redisNil:
                      warn "Pop ", taskkey, " failed"
                      flushFile(stdout)

      await sleepAsync(1000)
#+end_src

** serve

启动程序

#+begin_src nim :exports code :noweb yes :mkdirp yes :tangle /dev/shm/box-service/src/box_service.nim
  proc serve() =
    var
      name = prepareAddress(INADDR_ANY, 5008)
      sock = newAsyncNativeSocket(domain = Domain.AF_INET, sockType = SockType.SOCK_DGRAM, protocol = Protocol.IPPROTO_UDP)

    discard bindAddr(sock.SocketHandle, cast[ptr SockAddr](name), sizeof(Sockaddr_in).Socklen)
    info "Server bound to port 5008"
    flushFile(stdout)

    asyncCheck receive_always(sock)
    asyncCheck send_always(sock)
    asyncCheck check_always()
    run_forever()

  serve()
#+end_src

* PING

为了保持数据链路的畅通，设备会定时往 box service 发送 PING 命令。Box service 返
回 PONG 命令，把当前时间返回给设备。

#+begin_src nim :noweb-ref ping
  let
    uid = data.uid
    param = data.parameter
    sn = param.sn
  <<save-connections>>
  #info "PING uid", $uid
  <<pong>>
#+end_src
* PONG
#+begin_src nim :noweb-ref pong
  var pong_param: ref Parameter = new(Parameter)
  pong_param.sn = sn
  pong_param.version = 0
  pong_param.zone = 8 * 60 * 60 * 1000
  pong_param.timestamp = cast[int64]((epochTime() * 1000).toInt())
  var pkt = pong_param.encode_as(CommandType.PONG, uid)
  discard task_buffer.add((sockaddr: saddr, data: pkt))
  info "Prepare to send PONG to ", uid, " @ ", address
  flushFile(stdout)
#+end_src
* CONFIRM
收到设备发回的 CONFIRM 后，box service 去任务队列中查找对应的任务，并将其从任务
队列中删除。
#+begin_src nim :noweb-ref confirm
  let
    uid = data.uid
    param = data.parameter
    sn = param.sn
  <<save-connections>>
  let
    taskskey = "tasks." & $uid
    cmd_type = case param.cmd_type:
                 of 0: CommandType.UNKNOWN
                 of 1: CommandType.PING
                 of 2: CommandType.PONG
                 of 3: CommandType.CONFIRM
                 of 4: CommandType.LOCK_OFF
                 of 5: CommandType.LOCKS_OFF
                 of 6: CommandType.LOCK_STATUS
                 of 7: CommandType.LOCK_DETECT
                 of 8: CommandType.LOCK_STATUS_DETECT
                 of 9: CommandType.CHARGER_STATUS
                 of 10: CommandType.LIGHT_ON
                 of 11: CommandType.LIGHT_OFF
                 of 12: CommandType.FAN_ON
                 of 13: CommandType.FAN_OFF
                 of 14: CommandType.ULTRAVIOLET_ON
                 of 15: CommandType.ULTRAVIOLET_OFF
                 of 16: CommandType.CAMERA_ON
                 of 17: CommandType.CAMERA_OFF
                 of 18: CommandType.LOCK_DATA
                 else: CommandType.UNKNOWN
  flushFile(stdout)
  var taskstrs: seq[string] = @[]
  var lrange_result = redis_client.lRange(taskskey, 0, -1)
  yield lrange_result
  if not lrange_result.failed:
    taskstrs = lrange_result.read()
  else:
    redis_connected = false
    break mainloop
  case cmd_type:
    of CommandType.LOCK_OFF:
      <<lock-off-confirm>>
    of CommandType.LOCKS_OFF:
      <<locks-off-confirm>>
    of CommandType.LOCK_STATUS:
      <<lock-status-confirm>>
    of CommandType.LOCK_DETECT:
      <<lock-detect-confirm>>
    of CommandType.LOCK_STATUS_DETECT:
      <<lock-status-detect-confirm>>
    of CommandType.LIGHT_ON:
      <<light-on-confirm>>
    of CommandType.LIGHT_OFF:
      <<light-off-confirm>>
    of CommandType.FAN_ON:
      <<fan-on-confirm>>
    of CommandType.FAN_OFF:
      <<fan-off-confirm>>
    of CommandType.ULTRAVIOLET_ON:
      <<ultraviolet-on-confirm>>
    of CommandType.ULTRAVIOLET_OFF:
      <<ultraviolet-off-confirm>>
    of CommandType.CAMERA_ON:
      <<camera-on-confirm>>
    of CommandType.CAMERA_OFF:
      <<camera-off-confirm>>
    of CommandType.CHARGER_STATUS:
      <<charger-status-confirm>>
    else:
      warn "Invalid command ", param.cmd_type
      flushFile(stdout)
#+end_src

* LOCK-OFF
** 下行命令
#+begin_src nim :noweb-ref lock-off
  var lock_off: ref Parameter = new(Parameter)
  lock_off.board = cast[int8](task["board"].getNum())
  lock_off.lock = cast[int8](task["lock"].getNum())
  lock_off.pin = cast[int16](task["pin"].getNum())
  var pkt = lock_off.encode_as(CommandType.LOCK_OFF, uid)
  discard task_buffer.add((sockaddr: dst, data: pkt))
  var dstaddr = dst
  discard inet_ntop(posix.AF_INET, cast[pointer](addr dstaddr.sin_addr), cstring(address), len(address).int32)
  info "Prepare to send LOCK_OFF to ", uid, " @ ", address
  flushFile(stdout)
#+end_src
** 上行响应
#+begin_src nim :noweb-ref lock-off-confirm
  info "Confirm cmd type is LOCK_OFF, board: ", param.board, ", lock: ", param.lock
  flushFile(stdout)
  for taskstr in taskstrs:
    try:
      let task = parseJson(taskstr)
      if task["command"].getStr() == "lock-off" and cast[int8](task["board"].getNum()) == param.board and cast[int8](task["lock"].getNum()) == param.lock:
        asyncCheck redis_client.lRem(taskskey, taskstr, 1)
        info "Reomve from redis ", taskstr
        flushFile(stdout)
        break
    except:
      discard
#+end_src
* LOCKS-OFF
** 下行命令
#+begin_src nim :noweb-ref locks-off
  var locks_off: ref Parameter = new(Parameter)
  locks_off.board = cast[int8](task["board"].getNum())
  locks_off.locks = task["locks"].getElems().mapIt(cast[int8](it.getNum()))
  locks_off.pins = task["pins"].getElems().mapIt(cast[int16](it.getNum()))
  var pkt = locks_off.encode_as(CommandType.LOCKS_OFF, uid)
  discard task_buffer.add((sockaddr: dst, data: pkt))
  var dstaddr = dst
  discard inet_ntop(posix.AF_INET, cast[pointer](addr dstaddr.sin_addr), cstring(address), len(address).int32)
  info "Prepare to send LOCKS_OFF to ", uid, " @ ", address
  flushFile(stdout)
#+end_src
** 上行响应
#+begin_src nim :noweb-ref locks-off-confirm
  info "Confirm cmd type is LOCKS_OFF, board: ", param.board, ", locks: ", param.locks.mapIt($it).join(",")
  flushFile(stdout)
  let locks = param.locks.foldl(a * b, 1)
  for taskstr in taskstrs:
    try:
      let task = parseJson(taskstr)
      if task["command"].getStr() == "locks-off" and cast[int8](task["board"].getNum()) == param.board:
        let lockstmp = task["locks"].getElems().foldl(a * b.getNum(), 1'i64)
        if locks == lockstmp:
          asyncCheck redis_client.lRem(taskskey, taskstr, 1)
          info "Reomve from redis ", taskstr
          flushFile(stdout)
          break
    except:
      discard
#+end_src
* LOCK-STATUS
** 下行命令
#+begin_src nim :noweb-ref lock-status
  var lock_status: ref Parameter = new(Parameter)
  lock_status.board = cast[int8](task["board"].getNum())
  lock_status.pin = cast[int16](task["pin"].getNum())
  var pkt = lock_status.encode_as(CommandType.LOCK_STATUS, uid)
  discard task_buffer.add((sockaddr: dst, data: pkt))
  var dstaddr = dst
  discard inet_ntop(posix.AF_INET, cast[pointer](addr dstaddr.sin_addr), cstring(address), len(address).int32)
  info "Prepare to send LOCK_STATUS to ", uid, " @ ", address
  flushFile(stdout)
#+end_src
** 上行响应
#+begin_src nim :noweb-ref lock-status-confirm
  info "Confirm cmd type is LOCK_STATUS, board: ", param.board, ", state0: ", param.states[0], ", state1: ", param.states[1], ", state2: ", param.states[2]
  flushFile(stdout)
  for i in 0..len(param.states) - 1:
    var state = param.states[i]
    for j in 0..7:
      var skey = "lock-status." & $uid & "." & $param.board & "." & $((len(param.states) - 1 - i) * 8 + j + 1)
      if ((1 shl j) and state) != 0:
        var setex_result = redis_client.setEx(skey, 5, "1")
        yield setex_result
        if setex_result.failed():
          redis_connected = false
          break mainloop
      else:
        var setex_result = redis_client.setEx(skey, 5, "0")
        yield setex_result
        if setex_result.failed():
          redis_connected = false
          break mainloop
  for taskstr in taskstrs:
    try:
      let task = parseJson(taskstr)
      if task["command"].getStr() == "lock-status" and cast[int8](task["board"].getNum()) == param.board:
        asyncCheck redis_client.lRem(taskskey, taskstr, 1)
        break
    except:
      discard
#+end_src
* LOCK-DETECT
** 下行命令
#+begin_src nim :noweb-ref lock-detect
  var lock_status: ref Parameter = new(Parameter)
  lock_status.board = cast[int8](task["board"].getNum())
  lock_status.pin = cast[int16](task["pin"].getNum())
  var pkt = lock_status.encode_as(CommandType.LOCK_DETECT, uid)
  discard task_buffer.add((sockaddr: dst, data: pkt))
  var dstaddr = dst
  discard inet_ntop(posix.AF_INET, cast[pointer](addr dstaddr.sin_addr), cstring(address), len(address).int32)
  info "Prepare to send LOCK_DETECT to ", uid, " @ ", address
  flushFile(stdout)
#+end_src
** 上行响应
#+begin_src nim :noweb-ref lock-detect-confirm
  info "Confirm cmd type is LOCK_DETECT, board: ", param.board, ", state0: ", param.states[0], ", state1: ", param.states[1], ", state2: ", param.states[2]
  flushFile(stdout)
  for i in 0..len(param.states) - 1:
    var state = param.states[i]
    for j in 0..7:
      var skey = "lock-detect." & $uid & "." & $param.board & "." & $((len(param.states) - 1 - i) * 8 + j + 1)
      if ((1 shl j) and state) != 0:
        var setex_result = redis_client.setEx(skey, 5, "1")
        yield setex_result
        if setex_result.failed():
          redis_connected = false
          break mainloop
      else:
        var setex_result = redis_client.setEx(skey, 5, "0")
        yield setex_result
        if setex_result.failed():
          redis_connected = false
          break mainloop
  for taskstr in taskstrs:
    try:
      let task = parseJson(taskstr)
      if task["command"].getStr() == "lock-detect" and cast[int8](task["board"].getNum()) == param.board:
        asyncCheck redis_client.lRem(taskskey, taskstr, 1)
        break
    except:
      discard
#+end_src
* LOCK-STATUS-DETECT
** 下行命令
#+begin_src nim :noweb-ref lock-status-detect
  var lock_status: ref Parameter = new(Parameter)
  lock_status.board = cast[int8](task["board"].getNum())
  lock_status.pin = cast[int16](task["pin"].getNum())
  var pkt = lock_status.encode_as(CommandType.LOCK_STATUS_DETECT, uid)
  discard task_buffer.add((sockaddr: dst, data: pkt))
  var dstaddr = dst
  discard inet_ntop(posix.AF_INET, cast[pointer](addr dstaddr.sin_addr), cstring(address), len(address).int32)
  info "Prepare to send LOCK_STATUS_DETECT to ", uid, " @ ", address
  flushFile(stdout)
#+end_src
** 上行响应

响应里包括两个部分的数据，states 里存放的是锁的状态，locks 里存放的是测物条的状态

#+begin_src nim :noweb-ref lock-status-detect-confirm
  info "Confirm cmd type is LOCK_STATUS_DETECT, board: ", param.board, ", status: ", param.states[0], ", ", param.states[1], ", ", param.states[2], ", detect: ", param.locks[0], ", ", param.locks[1], ", ", param.locks[2]
  flushFile(stdout)
  for i in 0..len(param.states) - 1:
    var state = param.states[i]
    for j in 0..7:
      var skey = "lock-status." & $uid & "." & $param.board & "." & $((len(param.states) - 1 - i) * 8 + j + 1)
      if ((1 shl j) and state) != 0:
        var setex_result = redis_client.setEx(skey, 5, "1")
        yield setex_result
        if setex_result.failed():
          redis_connected = false
          break mainloop
      else:
        let setex_result = redis_client.setEx(skey, 5, "0")
        yield setex_result
        if setex_result.failed():
          redis_connected = false
          break mainloop
  for i in 0..len(param.locks) - 1:
    var state = param.locks[i]
    for j in 0..7:
      var skey = "lock-detect." & $uid & "." & $param.board & "." & $((len(param.locks) - 1 - i) * 8 + j + 1)
      if ((1 shl j) and state) != 0:
        var setex_result = redis_client.setEx(skey, 5, "1")
        yield setex_result
        if setex_result.failed():
          redis_connected = false
          break mainloop
      else:
        var setex_result = redis_client.setEx(skey, 5, "0")
        yield setex_result
        if setex_result.failed():
          redis_connected = false
          break mainloop
  for taskstr in taskstrs:
    let task = try: parseJson(taskstr)
               except: nil
    if task == nil:
      continue
    elif task["command"].getStr() == "lock-status-detect" and cast[int8](task["board"].getNum()) == param.board:
      let rem_result = redis_client.lRem(taskskey, taskstr, 1)
      yield rem_result
      if rem_result.failed():
        redis_connected = false
        break mainloop
#+end_src
* LOCK-DATA
设备定时把锁控板的状态和测物条的状态上报给服务端，服务端把这些状态同步到缓存中。
** 上行命令
#+begin_src nim :noweb-ref lock-data
  let
    uid = data.uid
    param = data.parameter
    sn = param.sn
    now = cast[int]((epochTime() * 1000).toInt() shr 10)
    timestamp = cast[int](param.timestamp shr 10)
    expires_at = if now > timestamp: 5 else: timestamp - now
  <<save-connections>>

  info "LOCK-DATA, board: ", param.board, ", status: ", param.states[0], ", ", param.states[1], ", ", param.states[2], ", detect: ", param.locks[0], ", ", param.locks[1], ", ", param.locks[2]
  flushFile(stdout)
  for i in 0..len(param.states) - 1:
    var state = param.states[i]
    for j in 0..7:
      var skey = "lock-status." & $uid & "." & $param.board & "." & $((len(param.states) - 1 - i) * 8 + j + 1)
      if ((1 shl j) and state) != 0:
        var setex_result = redis_client.setEx(skey, expires_at, "1")
        yield setex_result
        if setex_result.failed():
          redis_connected = false
          break mainloop
      else:
        let setex_result = redis_client.setEx(skey, expires_at, "0")
        yield setex_result
        if setex_result.failed():
          redis_connected = false
          break mainloop
  for i in 0..len(param.locks) - 1:
    var state = param.locks[i]
    for j in 0..7:
      var skey = "lock-detect." & $uid & "." & $param.board & "." & $((len(param.locks) - 1 - i) * 8 + j + 1)
      if ((1 shl j) and state) != 0:
        var setex_result = redis_client.setEx(skey, expires_at, "1")
        yield setex_result
        if setex_result.failed():
          redis_connected = false
          break mainloop
      else:
        var setex_result = redis_client.setEx(skey, expires_at, "0")
        yield setex_result
        if setex_result.failed():
          redis_connected = false
          break mainloop
  <<lock-data-confirm>>
#+end_src
** 下行响应
#+begin_src nim :noweb-ref lock-data-confirm
  var confirm_param: ref Parameter = new(Parameter)
  confirm_param.sn = sn
  confirm_param.version = 0
  confirm_param.cmd_type = 18 # CommandType.LOCK_DATA
  confirm_param.zone = 8 * 60 * 60 * 1000
  confirm_param.timestamp = cast[int64]((epochTime() * 1000).toInt())
  var pkt = confirm_param.encode_as(CommandType.CONFIRM, uid)
  discard task_buffer.add((sockaddr: saddr, data: pkt))
  info "Prepare to send CONFIRM of LOCK_DATA to ", uid, " @ ", address
  flushFile(stdout)
#+end_src

* LIGHT-ON
** 下行命令
#+begin_src nim :noweb-ref light-on
  var light_on: ref Parameter = new(Parameter)
  light_on.pin = cast[int16](task["pin"].getNum())
  var pkt = light_on.encode_as(CommandType.LIGHT_ON, uid)
  discard task_buffer.add((sockaddr: dst, data: pkt))
  var dstaddr = dst
  discard inet_ntop(posix.AF_INET, cast[pointer](addr dstaddr.sin_addr), cstring(address), len(address).int32)
  info "Prepare to send LIGHT_ON to ", uid, " @ ", address
  flushFile(stdout)
#+end_src
** 上行响应
#+begin_src nim :noweb-ref light-on-confirm
  info "Confirm cmd type is LIGHT_ON"
  flushFile(stdout)
  for taskstr in taskstrs:
    try:
      let task = parseJson(taskstr)
      if task["command"].getStr() == "light-on":
        asyncCheck redis_client.lRem(taskskey, taskstr, 1)
        break
    except:
      discard
#+end_src
* LIGHT-OFF
** 下行命令
#+begin_src nim :noweb-ref light-off
  var light_off: ref Parameter = new(Parameter)
  light_off.pin = cast[int16](task["pin"].getNum())
  var pkt = light_off.encode_as(CommandType.LIGHT_OFF, uid)
  discard task_buffer.add((sockaddr: dst, data: pkt))
  var dstaddr = dst
  discard inet_ntop(posix.AF_INET, cast[pointer](addr dstaddr.sin_addr), cstring(address), len(address).int32)
  info "Prepare to send LIGHT_Off to ", uid, " @ ", address
  flushFile(stdout)
#+end_src
** 上行响应
#+begin_src nim :noweb-ref light-off-confirm
  info "Confirm cmd type is LIGHT_OFF"
  flushFile(stdout)
  for taskstr in taskstrs:
    try:
      let task = parseJson(taskstr)
      if task["command"].getStr() == "light-off":
        asyncCheck redis_client.lRem(taskskey, taskstr, 1)
        break
    except:
      discard
#+end_src
* FAN-ON
** 下行命令
#+begin_src nim :noweb-ref fan-on
  var fan_on: ref Parameter = new(Parameter)
  fan_on.pin = cast[int16](task["pin"].getNum())
  var pkt = fan_on.encode_as(CommandType.FAN_ON, uid)
  discard task_buffer.add((sockaddr: dst, data: pkt))
  var dstaddr = dst
  discard inet_ntop(posix.AF_INET, cast[pointer](addr dstaddr.sin_addr), cstring(address), len(address).int32)
  info "Prepare to send FAN_ON to ", uid, " @ ", address
  flushFile(stdout)
#+end_src
** 上行响应
#+begin_src nim :noweb-ref fan-on-confirm
  info "Confirm cmd type is FAN_ON"
  flushFile(stdout)
  for taskstr in taskstrs:
    try:
      let task = parseJson(taskstr)
      if task["command"].getStr() == "fan-on":
        asyncCheck redis_client.lRem(taskskey, taskstr, 1)
        break
    except:
      discard
#+end_src
* FAN-OFF
** 下行命令
#+begin_src nim :noweb-ref fan-off
  var fan_off: ref Parameter = new(Parameter)
  fan_off.pin = cast[int16](task["pin"].getNum())
  var pkt = fan_off.encode_as(CommandType.FAN_OFF, uid)
  discard task_buffer.add((sockaddr: dst, data: pkt))
  var dstaddr = dst
  discard inet_ntop(posix.AF_INET, cast[pointer](addr dstaddr.sin_addr), cstring(address), len(address).int32)
  info "Prepare to send FAN_Off to ", uid, " @ ", address
  flushFile(stdout)
#+end_src
** 上行响应
#+begin_src nim :noweb-ref fan-off-confirm
  info "Confirm cmd type is FAN_OFF"
  flushFile(stdout)
  for taskstr in taskstrs:
    try:
      let task = parseJson(taskstr)
      if task["command"].getStr() == "fan-off":
        asyncCheck redis_client.lRem(taskskey, taskstr, 1)
        break
    except:
      discard
#+end_src
* ULTRAVIOLET-ON
** 下行命令
#+begin_src nim :noweb-ref ultraviolet-on
  var ultraviolet_on: ref Parameter = new(Parameter)
  ultraviolet_on.pin = cast[int16](task["pin"].getNum())
  var pkt = ultraviolet_on.encode_as(CommandType.ULTRAVIOLET_ON, uid)
  discard task_buffer.add((sockaddr: dst, data: pkt))
  var dstaddr = dst
  discard inet_ntop(posix.AF_INET, cast[pointer](addr dstaddr.sin_addr), cstring(address), len(address).int32)
  info "Prepare to send ULTRAVIOLET_ON to ", uid, " @ ", address
  flushFile(stdout)
#+end_src
** 上行响应
#+begin_src nim :noweb-ref ultraviolet-on-confirm
  info "Confirm cmd type is ULTRAVIOLET_ON"
  flushFile(stdout)
  for taskstr in taskstrs:
    try:
      let task = parseJson(taskstr)
      if task["command"].getStr() == "ultraviolet-on":
        asyncCheck redis_client.lRem(taskskey, taskstr, 1)
        break
    except:
      discard
#+end_src
* ULTRAVIOLET-OFF
** 下行命令
#+begin_src nim :noweb-ref ultraviolet-off
  var ultraviolet_off: ref Parameter = new(Parameter)
  ultraviolet_off.pin = cast[int16](task["pin"].getNum())
  var pkt = ultraviolet_off.encode_as(CommandType.ULTRAVIOLET_OFF, uid)
  discard task_buffer.add((sockaddr: dst, data: pkt))
  var dstaddr = dst
  discard inet_ntop(posix.AF_INET, cast[pointer](addr dstaddr.sin_addr), cstring(address), len(address).int32)
  info "Prepare to send ULTRAVIOLET_OFF to ", uid, " @ ", address
  flushFile(stdout)
#+end_src
** 上行响应
#+begin_src nim :noweb-ref ultraviolet-off-confirm
  info "Confirm cmd type is ULTRAVIOLET_OFF"
  flushFile(stdout)
  for taskstr in taskstrs:
    try:
      let task = parseJson(taskstr)
      if task["command"].getStr() == "ultraviolet-off":
        asyncCheck redis_client.lRem(taskskey, taskstr, 1)
        break
    except:
      discard
#+end_src

* CAMERA-ON
** 下行命令
#+begin_src nim :noweb-ref camera-on
  var camera_on: ref Parameter = new(Parameter)
  camera_on.pin = cast[int16](task["pin"].getNum())
  var pkt = camera_on.encode_as(CommandType.CAMERA_ON, uid)
  discard task_buffer.add((sockaddr: dst, data: pkt))
  var dstaddr = dst
  discard inet_ntop(posix.AF_INET, cast[pointer](addr dstaddr.sin_addr), cstring(address), len(address).int32)
  info "Prepare to send CAMERA_ON to ", uid, " @ ", address
  flushFile(stdout)
#+end_src
** 上行响应
#+begin_src nim :noweb-ref camera-on-confirm
  info "Confirm cmd type is CAMERA_ON"
  flushFile(stdout)
  for taskstr in taskstrs:
    try:
      let task = parseJson(taskstr)
      if task["command"].getStr() == "camera-on":
        asyncCheck redis_client.lRem(taskskey, taskstr, 1)
        break
    except:
      discard
#+end_src
* CAMERA-OFF
** 下行命令
#+begin_src nim :noweb-ref camera-off
  var camera_off: ref Parameter = new(Parameter)
  camera_off.pin = cast[int16](task["pin"].getNum())
  var pkt = camera_off.encode_as(CommandType.CAMERA_OFF, uid)
  discard task_buffer.add((sockaddr: dst, data: pkt))
  var dstaddr = dst
  discard inet_ntop(posix.AF_INET, cast[pointer](addr dstaddr.sin_addr), cstring(address), len(address).int32)
  info "Prepare to send CAMERA_OFF to ", uid, " @ ", address
  flushFile(stdout)
#+end_src
** 上行响应
#+begin_src nim :noweb-ref camera-off-confirm
  info "Confirm cmd type is CAMERA_OFF"
  flushFile(stdout)
  for taskstr in taskstrs:
    try:
      let task = parseJson(taskstr)
      if task["command"].getStr() == "camera-off":
        info "remove task in queue: ", taskstr
        flushFile(stdout)
        asyncCheck redis_client.lRem(taskskey, taskstr, 1)
        break
    except:
      discard
#+end_src

* CHARGER-STATUS
** 下行命令
#+begin_src nim :noweb-ref charger-status
  var camera_off: ref Parameter = new(Parameter)
  var pkt = camera_off.encode_as(CommandType.CHARGER_STATUS, uid)
  discard task_buffer.add((sockaddr: dst, data: pkt))
  var dstaddr = dst
  discard inet_ntop(posix.AF_INET, cast[pointer](addr dstaddr.sin_addr), cstring(address), len(address).int32)
  info "Prepare to send CHARGER_STATUS to ", uid, " @ ", address
  flushFile(stdout)
#+end_src
** 上行响应
#+begin_src nim :noweb-ref charger-status-confirm
  info "Confirm cmd type is CHARGER_STATUS, charger1: ", param.chargers[0], ", charger2: ", param.chargers[1], ", charger3: ", param.chargers[2], ", charger4: ", param.chargers[3]
  flushFile(stdout)
  for i in 0..len(param.chargers) - 1:
    var
      state = param.chargers[i]
      skey = "charger-status." & $uid & "." & $(i + 1)
      setex_result = redis_client.setEx(skey, 30, $state)
    yield setex_result
    if setex_result.failed():
      redis_connected = false
  for taskstr in taskstrs:
    try:
      let task = parseJson(taskstr)
      if task["command"].getStr() == "charger-status":
        info "remove task in queue: ", taskstr
        flushFile(stdout)
        asyncCheck redis_client.lRem(taskskey, taskstr, 1)
        break
    except:
      discard
#+end_src
* 数据封包
#+begin_src nim :exports code :noweb yes :mkdirp yes :tangle /dev/shm/box-service/src/box_servicepkg/box_packer.nim
  import parameter, zeropack
  import hashes, logging, sequtils, strutils
  type
    CommandType* {.pure.} = enum
      UNKNOWN = 0, PING = 1, PONG = 2, CONFIRM = 3, LOCK_OFF = 4, LOCKS_OFF = 5, LOCK_STATUS = 6, LOCK_DETECT = 7, LOCK_STATUS_DETECT = 8, CHARGER_STATUS = 9, LIGHT_ON = 10, LIGHT_OFF = 11, FAN_ON = 12, FAN_OFF = 13, ULTRAVIOLET_ON = 14, ULTRAVIOLET_OFF = 15, CAMERA_ON = 16, CAMERA_OFF = 17, LOCK_DATA = 18
    UID* = array[0..11, byte]
    PackResultObject* = object of RootObj
      uid*: UID
      cmd_type*: CommandType
      parameter*: ref Parameter
    PackResult* = ref PackResultObject

  const version: int = 0
  const CRC8_KEY: uint8 = 0x07

  proc `$`*(uid: UID): string =
    return uid.mapIt(toHex(cast[BiggestInt](it), 2)).join("-")

  proc hash*(x: UID): Hash =
    let
      byte0 = x[0] xor x[4] xor x[8]
      byte1 = x[1] xor x[5] xor x[9]
      byte2 = x[2] xor x[6] xor x[10]
      byte3 = x[3] xor x[7] xor x[11]
    result = (cast[int](byte0) shl 24) + (cast[int](byte1) shl 16) + (cast[int](byte2) shl 8) + cast[int](byte3)

  proc parseUID*(uidstr: string): UID =
    let bytes = uidstr.split('-').mapIt(cast[byte](parseHexInt(it)))
    result[0] = bytes[0]
    result[1] = bytes[1]
    result[2] = bytes[2]
    result[3] = bytes[3]
    result[4] = bytes[4]
    result[5] = bytes[5]
    result[6] = bytes[6]
    result[7] = bytes[7]
    result[8] = bytes[8]
    result[9] = bytes[9]
    result[10] = bytes[10]
    result[11] = bytes[11]

  proc crc8(buf: seq[byte], offset: int, len: int): uint8 =
    var bptr = offset
    let stop = offset + len
    while bptr != stop:
      var i: uint8 = 0x80
      while i != 0:
        if (result and 0x80) != 0:
          result = result shl 1
          result = result xor CRC8_KEY
        else:
          result = result shl 1
        if (buf[bptr] and i) != 0:
          result = result xor CRC8_KEY
        i = i shr 1
      bptr += 1

  proc encode(payload: seq[byte], cmd_type: CommandType, uid: UID): seq[byte] =
    let
      payload_size = len(payload)
      header_size = 1 + 1 + 1 + 12
      size: int = header_size + payload_size
      uid_start = 3
    var buf: seq[byte] = newSeq[byte](size)
    buf[0] = cast[byte](size and 0xFF)
    buf[2] = cast[byte](ord(cmd_type))
    for i in 0..11:
      buf[uid_start + i] = uid[i]
    var payload_start = header_size
    for i in 0..(payload_size - 1):
      buf[payload_start + i] = payload[i]
    buf[1] = crc8(buf, 2, payload_size + header_size - 2)
    return buf

  proc encode_as*(parameter: ref Parameter, cmd_type: CommandType, uid: UID): seq[byte] =
    let size: int = parameter.calculate_size()
    var buf: seq[byte] = newSeq[byte](size)
    discard parameter.encode_into(buf, 0)
    let zipped_buf = zeropack(buf)
    return encode(zipped_buf, cmd_type, uid)

  proc decode*(buf: seq[byte], offset: int, length: int): PackResult =
    let
      header_size = 1 + 1 + 1 + 12
      packed_size = cast[int](buf[offset])
    if length != packed_size:
      warn "Length is invalid, got ", $length, " but need ", packed_size
      flushFile(stdout)
      #echo hexdump(buf, length)
      return nil
    let checksum: uint8 = crc8(buf, offset + 2, length - 2)
    if checksum != buf[offset + 1]:
      warn "Checksum is invalid, got ", buf[offset + 1], " but should be ", checksum, "\n"
      flushFile(stdout)
      return nil
    var uid: UID
    for i in 0..11:
      uid[i] = buf[offset + 1 + 1 + 1 + i]
    let unzipped: seq[byte] = unzeropack(buf, offset + header_size, length - header_size)
    case (buf[offset + 1 + 1]):
      of 1:
        result = PackResult(cmd_type: CommandType.PING, uid: uid, parameter: parameter.decode_from(unzipped, 0))
      of 3:
        result = PackResult(cmd_type: CommandType.CONFIRM, uid: uid, parameter: parameter.decode_from(unzipped, 0))
      of 18:
        result = PackResult(cmd_type: CommandType.LOCK_DATA, uid: uid, parameter: parameter.decode_from(unzipped, 0))
      else:
        warn "Command type is invalid\n"
        flushFile(stdout)
        return nil
#+end_src
* 支援方法
** 保存连接

将设备的地址和对应的 Socket Address 保存到 device_connections 中，以后可以根据此
地址，主动给设备发送数据。同时把设备的地址加入到当前活跃设备集合中。

#+begin_src nim :noweb-ref save-connections
  device_connections[uid] = (expires_at: epochTime().toInt() + 60 * 1024, sockaddr: saddr)
  let activated_key = "box.activated." & getDateStr() & "." & $getLocalTime(getTime()).hour
  var sadd_result = redis_client.sAdd(activated_key, $uid)
  yield sadd_result
  if sadd_result.failed:
    redis_connected = false
    break mainloop
#+end_src

** hexdump

#+begin_src nim :noweb-ref hexdump
  proc hexdump(buf: seq[byte], size: int): string =
    var output = ""
    for i in 0..(size - 1):
      output.add("$1 " % (toHex(buf[i])))
      if i mod 8 == 7:
        output.add("\n")
    return output
#+end_src
