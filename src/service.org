* 基本框架

Box service 是设备连接到系统的通道。设备通过 box service 上报数据；管理系统通过
box service 给设备发送命令。服务采用异步方式编写，启动后侦听 UDP/5008 端口，处理
收到的请求，并把响应返回给请求的设备；或者把任务数据下发给设备。

#+begin_src nim :exports code :noweb yes :mkdirp yes :tangle /dev/shm/box-service/src/box_service.nim
  import asyncdispatch, asyncnet, base64, httpclient, json, logging, md5, nativesockets, posix, redis, ringbuffer, sequtils, strfmt, strutils, tables, times
  import box_servicepkg/box_packer, box_servicepkg/parameter

  <<hexdump>>

  type
    Task = tuple[uid: box_packer.UID, sockaddr: Sockaddr_in, data: seq[byte]]

  var device_connections: Table[box_packer.UID, tuple[expires_at: int, sockaddr: Sockaddr_in]] = initTable[box_packer.UID, tuple[expires_at: int, sockaddr: Sockaddr_in]]()
  var task_buffer: RingBuffer[Task] = newRingBuffer[Task](bitsize = 10)
  var pin_table: Table[box_packer.UID, RingBuffer[int16]] = initTable[box_packer.UID, RingBuffer[int16]]()
  var L = newConsoleLogger(fmtStr = "$levelid [$datetime] : ")
  addHandler(L)

  proc prepareAddress(intaddr: uint32, intport: uint16): ptr Sockaddr_in =
    result = cast[ptr Sockaddr_in](alloc0(sizeof(Sockaddr_in)))
    result.sin_family = toInt(nativesockets.AF_INET)
    result.sin_port = nativesockets.htons(intport)
    result.sin_addr.s_addr = nativesockets.htonl(intaddr)

#+end_src

DevicePin 用于去除来自设备的重复命令。来自设备的命令都附带一个 PIN，如果该 PIN
在 pin_buffer 中存在，则说明该命令已经收到，此次请求可以忽略。

** send

发送任务数据到设备。发送任务检查 task_buffer 中的发送数据，有任务就发送到对应的
设备，没有就休眠 1 秒。

#+begin_src nim :exports code :noweb yes :mkdirp yes :tangle /dev/shm/box-service/src/box_service.nim
  proc send_always(sock: AsyncFD) {.async.} =
    var
      sndbuf: ref array[1024, byte] = new(array[1024, byte])
      address = newString(128)
      slen = sizeof(Sockaddr_in).SockLen
    while true:
      if len(task_buffer) > 0'u32:
        let task = pop(task_buffer)
        zeroMem(cast[pointer](sndbuf), 1024)
        let encoded = base64.encode[byte](task.data, lineLen = 1024)
        for i in 0..(len(encoded) - 1):
          sndbuf[i] = ord(encoded[i])
        var dst = task.sockaddr
        let sendto_future = send_to(socket = sock, data = cast[pointer](sndbuf), size = len(encoded), saddr = cast[ptr SockAddr](addr(dst)), saddrLen = slen)
        yield sendto_future
        if sendto_future.failed:
          device_connections.del(task.uid)
          error "Send ", len(encoded), " byte(s) to ", task.uid, " @ ", address, ":", dst.sin_port, " failed"
          continue
        discard inet_ntop(posix.AF_INET, cast[pointer](addr dst.sin_addr), cstring(address), len(address).int32)
        address = address.strip(chars = {'\0'})
        info "Send ", len(encoded), " byte(s) to ", task.uid, " @ ", address, ":", dst.sin_port, ": ", encoded
      else:
        await sleepAsync(1000)
#+end_src

** receive

从设备接收数据。

#+begin_src nim :exports code :noweb yes :mkdirp yes :tangle /dev/shm/box-service/src/box_service.nim
  proc receive_always(sock: AsyncFD) {.async.} =
    var
      rcvbuf: ref array[1024, byte] = new(array[1024, byte])
      address = newString(128)
      slen = sizeof(Sockaddr_in).SockLen
    let redis_client: AsyncRedis = await openAsync()
    while true:
      zeroMem(cast[pointer](rcvbuf), 1024)
      var saddr = Sockaddr_in()
      zeroMem(cast[pointer](addr(saddr)), sizeof(Sockaddr_in))
      let blen = await sock.recvFromInto(cast[pointer](rcvbuf), 1024, cast[ptr SockAddr](addr(saddr)), addr(slen))
      discard inet_ntop(posix.AF_INET, cast[pointer](addr saddr.sin_addr), cstring(address), len(address).int32)
      address = address.strip(chars = {'\0'})
      var received = ""
      for i in 0..blen - 1:
        received &= chr(rcvbuf[i])
      info "Received ", blen, " bytes: ", received
      let rcvd: string = base64.decode($cast[cstring](rcvbuf))
      for i in 0..len(rcvd) - 1:
        rcvbuf[i] = ord(rcvd[i])
      # info hexdump(@(rcvbuf[]), len(rcvd))
      var data: PackResult = box_packer.decode(@(rcvbuf[]), 0, len(rcvd))
      if data != nil:
        case data.cmd_type:
          of CommandType.PING:
            info "Receive PING from ", address, ":", saddr.sin_port
            <<ping>>
          of CommandType.CONFIRM:
            info "Receive CONFIRM of ", CommandType(data.parameter.cmd_type) , " from ", address, ":", saddr.sin_port
            <<confirm>>
          of CommandType.LOCK_OFF:
            info "Receive LOCK_OFF from ", address, ":", saddr.sin_port
            <<client-lock-off>>
          of CommandType.LOCK_DATA:
            info "Receive LOCK_DATA from ", address, ":", saddr.sin_port
            <<lock-data>>
          else:
            info "Receive UNKNOWN from ", address, ":", saddr.sin_port
      else:
        info "Receive invalid packet from ", address, ":", saddr.sin_port
#+end_src

** check task

检查任务队列。第一步，从已经建立连接的设备任务队列中获取任务，如果任务过期了，就
不发送任务；否则，就根据任务的类型将任务填充到 task_buffer 中。

#+begin_src nim :exports code :noweb yes :mkdirp yes :tangle /dev/shm/box-service/src/box_service.nim
  proc check_always() {.async.} =
    var address = newString(128)
    let redis_client: AsyncRedis = await openAsync()
    var sending_time: Table[box_packer.UID, int64] = initTable[box_packer.UID, int64]()
    var operation_count = 0
    while true:
      operation_count = 0 # did we do redis or send something?
      let now = epochTime().toInt()
      for uid, pair in device_connections.pairs():
        let
          expires_at = pair[0]
          dst = pair[1]
        if expires_at < now:
          warn "Connection of uid ", uid, " is expired"
          device_connections.del(uid)
          continue
        let
          taskkey = "tasks." & $uid
          taskstr = await redis_client.lindex(taskkey, 0)
        if taskstr == redisNil:
          #warn "Got nothing in task queue ", taskkey
          continue
        else:
          let task = try: parseJson(taskstr) except: nil
          if task == nil or task["expires-at"].getNum() < now:
            let lrem_result = await redis_client.lrem(taskkey, taskstr, 1)
            if lrem_result == 0:
              warn "Cannot remove expired task ", taskstr, " from ", taskkey
            else:
              task["status"] = % "expired"
              task["occurred-at"] = %(getDateStr() & " " & getClockStr())
              discard await redis_client.rpush("tasklog." & $uid & "." & getDateStr(), $task)
              info "Remove expired task ", taskstr, " from ", taskkey
              operation_count += 1
          else:
            if sending_time.contains(uid):
              if now - sending_time[uid] < 2: # Don't resend in 2 seconds
                continue
            sending_time[uid] = now
            operation_count += 1
            info "Found task for ", $uid
            let
              tasklog_key = "tasklog." & $uid & "." & getDateStr()
              tasklog_len = cast[int](await redis_client.llen(tasklog_key))
              tasklogs = if tasklog_len > 100: await redis_client.lrange(tasklog_key, tasklog_len - 100, tasklog_len - 1) else: await redis_client.lrange(tasklog_key, 0, -1)
            var found_log = false
            for logstr in tasklogs:
              let log = try: parseJson(logstr) except: nil
              if log != nil and task["command"].getStr() == log["command"].getStr() and task["expires-at"].getNum() == log["expires-at"].getNum():
                if log.has_key("pin") and task.has_key("pin") and log["pin"].getNum() == task["pin"].getNum():
                  if log["status"].getStr() == "sending":
                    found_log = true
                    break
                elif log.has_key("pins") and task.has_key("pins") and len(log["pins"]) == len(task["pins"]):
                  var found_pins = true
                  for i in 0..len(log["pins"]) - 1:
                    if log["pins"][i].getNum() != task["pins"][i].getNum():
                      found_pins = false
                      break
                  if found_pins and log["status"].getStr() == "sending":
                    found_log = true
                    break
            if not found_log:
              task["status"] = % "sending"
              task["occurred-at"] = %(getDateStr() & " " & getClockStr())
              discard await redis_client.rpush(tasklog_key, $task)
            case task["command"].getStr():
              of "lock-off":
                <<lock-off>>
              of "locks-off":
                <<locks-off>>
              of "lock-status":
                <<lock-status>>
              of "lock-detect":
                <<lock-detect>>
              of "lock-status-detect":
                <<lock-status-detect>>
              of "light-on":
                <<light-on>>
              of "light-off":
                <<light-off>>
              of "fan-on":
                <<fan-on>>
              of "fan-off":
                <<fan-off>>
              of "ultraviolet-on":
                <<ultraviolet-on>>
              of "ultraviolet-off":
                <<ultraviolet-off>>
              of "camera-on":
                <<camera-on>>
              of "camera-off":
                <<camera-off>>
              of "charger-status":
                <<charger-status>>
              of "play":
                <<play>>
              else:
                let rpop_result = await redis_client.rpop(taskkey)
                if rpop_result == redisNil:
                  warn "Pop ", taskkey, " failed"
      if operation_count == 0:
        await sleepAsync(1000)
#+end_src

** serve

启动程序

#+begin_src nim :exports code :noweb yes :mkdirp yes :tangle /dev/shm/box-service/src/box_service.nim
  proc serve() =
    var
      name = prepareAddress(INADDR_ANY, 5008)
      sock = newAsyncNativeSocket(domain = Domain.AF_INET, sockType = SockType.SOCK_DGRAM, protocol = Protocol.IPPROTO_UDP)

    discard bindAddr(sock.SocketHandle, cast[ptr SockAddr](name), sizeof(Sockaddr_in).Socklen)
    info "Server bound to port 5008"

    asyncCheck receive_always(sock)
    asyncCheck send_always(sock)
    asyncCheck check_always()
    run_forever()

  serve()
#+end_src

* PING

为了保持数据链路的畅通，设备会定时往 box service 发送 PING 命令。Box service 返
回 PONG 命令，把当前时间返回给设备。

#+begin_src nim :noweb-ref ping
  let
    uid = data.uid
    param = data.parameter
    sn = param.sn
  <<save-connections>>
  #info "PING uid", $uid
  let rssi_key = "rssi." & $uid & "." & getDateStr() & "." & $getLocalTime(getTime()).hour.format("02d") & "." & $getLocalTime(getTime()).minute.format("02d")
  await redis_client.setk(rssi_key, $param.rssi)
  <<pong>>
#+end_src
* PONG
#+begin_src nim :noweb-ref pong
  var pong_param: ref Parameter = new(Parameter)
  pong_param.sn = sn
  pong_param.version = 0
  pong_param.zone = 8 * 60 * 60 * 1000
  pong_param.timestamp = cast[int64]((epochTime() * 1000).toInt())
  var pkt = pong_param.encode_as(CommandType.PONG, uid)
  discard task_buffer.add((uid: uid, sockaddr: saddr, data: pkt))
  info "Prepare to send PONG to ", uid, " @ ", address, ":", saddr.sin_port
#+end_src
* CONFIRM
收到设备发回的 CONFIRM 后，box service 去任务队列中查找对应的任务，并将其从任务
队列中删除。
#+begin_src nim :noweb-ref confirm
  let
    uid = data.uid
    param = data.parameter
    sn = param.sn
  <<save-connections>>
  let
    taskkey = "tasks." & $uid
    cmd_type = case param.cmd_type:
                 of 0: CommandType.UNKNOWN
                 of 1: CommandType.PING
                 of 2: CommandType.PONG
                 of 3: CommandType.CONFIRM
                 of 4: CommandType.LOCK_OFF
                 of 5: CommandType.LOCKS_OFF
                 of 6: CommandType.LOCK_STATUS
                 of 7: CommandType.LOCK_DETECT
                 of 8: CommandType.LOCK_STATUS_DETECT
                 of 9: CommandType.CHARGER_STATUS
                 of 10: CommandType.LIGHT_ON
                 of 11: CommandType.LIGHT_OFF
                 of 12: CommandType.FAN_ON
                 of 13: CommandType.FAN_OFF
                 of 14: CommandType.ULTRAVIOLET_ON
                 of 15: CommandType.ULTRAVIOLET_OFF
                 of 16: CommandType.CAMERA_ON
                 of 17: CommandType.CAMERA_OFF
                 of 18: CommandType.LOCK_DATA
                 of 19: CommandType.PLAY
                 else: CommandType.UNKNOWN
  let taskstrs: seq[string] = await redis_client.lrange(taskkey, 0, -1)
  if len(taskstrs) == 0:
    info "Nothing in task queue ", taskkey
  case cmd_type:
    of CommandType.LOCK_OFF:
      <<lock-off-confirm>>
    of CommandType.LOCKS_OFF:
      <<locks-off-confirm>>
    of CommandType.LOCK_STATUS:
      <<lock-status-confirm>>
    of CommandType.LOCK_DETECT:
      <<lock-detect-confirm>>
    of CommandType.LOCK_STATUS_DETECT:
      <<lock-status-detect-confirm>>
    of CommandType.LIGHT_ON:
      <<light-on-confirm>>
    of CommandType.LIGHT_OFF:
      <<light-off-confirm>>
    of CommandType.FAN_ON:
      <<fan-on-confirm>>
    of CommandType.FAN_OFF:
      <<fan-off-confirm>>
    of CommandType.ULTRAVIOLET_ON:
      <<ultraviolet-on-confirm>>
    of CommandType.ULTRAVIOLET_OFF:
      <<ultraviolet-off-confirm>>
    of CommandType.CAMERA_ON:
      <<camera-on-confirm>>
    of CommandType.CAMERA_OFF:
      <<camera-off-confirm>>
    of CommandType.CHARGER_STATUS:
      <<charger-status-confirm>>
    of CommandType.PLAY:
      <<play-confirm>>
    else:
      warn "Invalid command ", param.cmd_type
#+end_src

在确认的同时，需要确认消息记录到日志中。

#+begin_src nim :noweb-ref update-status-to-sent
  task["status"] = %"sent"
  task["occurred-at"] = %(getDateStr() & " " & getClockStr())
  discard await redis_client.rpush("tasklog." & $uid & "." & getDateStr(), $task)
#+end_src

* CLIENT-LOCK-OFF
从客户端发来的开锁指令，需要转发到业务系统去。

#+begin_src nim :noweb-ref client-lock-off
  let
    uid = data.uid
    param = data.parameter
    sn = param.sn
    lock = param.lock
    reader = param.card_reader
    card_no = param.card_no
    pin = param.pin
  <<save-connections>>
  var confirm: ref Parameter = new(Parameter)
  confirm.sn = sn
  confirm.version = 0
  confirm.cmd_type = ord(CommandType.LOCK_OFF)
  confirm.lock = lock
  confirm.card_reader = reader
  confirm.card_no = confirm.card_no
  let pkt = confirm.encode_as(CommandType.CONFIRM, uid)
  discard task_buffer.add((uid: uid, sockaddr: saddr, data: pkt))
  info "Prepare to send CONFIRM of LOCK_OFF to ", uid, " @ ", address, ":", saddr.sin_port
  if pin_table.contains(uid) and pin_table[uid].find(pin) != -1:
    info "Found dup command LOCK_OFF from reader ", reader, " at ", uid
  else:
    if not pin_table.contains(uid):
      pin_table[uid] = newRingBuffer[int16](bitsize = 3)
    if pin_table[uid].add(pin) == 1:
      let
        bsclient = newAsyncHttpClient()
        sign = toLower($toMD5("md=" & $uid & "&sno=" & $lock & "&sw=" & $reader & "&u=" & $card_no & "&key=qbtstvvs05pyiwjj50uuddydho2srdlm"))
        response = await bsclient.request("https://book.fengchaohuzhu.com/" & (if lock == 0: "swing/back" else: "swing/orsark"), httpMethod = HttpPost, body = $ %*{ "u": $card_no, "md": $uid, "sw": $reader, "sno": $lock, "t": $epochTime().toInt(), "sign": sign})
      if response.status == "200":
        let body = await response.body()
        let resp = try: parseJson(body) except: nil
        if resp != nil:
          case resp["code"].getNum():
            of 1: discard
            else: discard
#+end_src

* LOCK-OFF
** 下行命令
#+begin_src nim :noweb-ref lock-off
  var lock_off: ref Parameter = new(Parameter)
  lock_off.board = cast[int8](task["board"].getNum())
  lock_off.lock = cast[int8](task["lock"].getNum())
  lock_off.pin = cast[int16](task["pin"].getNum())
  var pkt = lock_off.encode_as(CommandType.LOCK_OFF, uid)
  discard task_buffer.add((uid: uid, sockaddr: dst, data: pkt))
  var saddr = dst
  <<ntop>>
  info "Prepare to send LOCK_OFF(board: ", lock_off.board, ", lock: ", lock_off.lock , ", pin: ", lock_off.pin , ") to ", uid, " @ ", address, ":", dst.sin_port
#+end_src
** 上行响应
#+begin_src nim :noweb-ref lock-off-confirm
  info "Confirm cmd type is LOCK_OFF, board: ", param.board, ", lock: ", param.lock
  for taskstr in taskstrs:
    let task = try: parseJson(taskstr) except: nil
    if task != nil and task["command"].getStr() == "lock-off" and cast[int8](task["board"].getNum()) == param.board and cast[int8](task["lock"].getNum()) == param.lock:
      <<remove-task>>
#+end_src
* LOCKS-OFF
** 下行命令
#+begin_src nim :noweb-ref locks-off
  var locks_off: ref Parameter = new(Parameter)
  locks_off.board = cast[int8](task["board"].getNum())
  locks_off.locks = task["locks"].getElems().mapIt(cast[int8](it.getNum()))
  locks_off.pins = task["pins"].getElems().mapIt(cast[int16](it.getNum()))
  var pkt = locks_off.encode_as(CommandType.LOCKS_OFF, uid)
  discard task_buffer.add((uid: uid, sockaddr: dst, data: pkt))
  var saddr = dst
  <<ntop>>
  info "Prepare to send LOCKS_OFF(board: ", locks_off.board, ", locks: ", locks_off.locks, ", pins: ", locks_off.pins, ") to ", uid, " @ ", address
#+end_src
** 上行响应
#+begin_src nim :noweb-ref locks-off-confirm
  info "Confirm cmd type is LOCKS_OFF, board: ", param.board, ", locks: ", param.locks.mapIt($it).join(",")
  let locks = param.locks.foldl(a * b, 1)
  for taskstr in taskstrs:
    let task = try: parseJson(taskstr) except: nil
    if task != nil and task["command"].getStr() == "locks-off" and cast[int8](task["board"].getNum()) == param.board:
      let lockstmp = task["locks"].getElems().foldl(a * b.getNum(), 1'i64)
      if locks == lockstmp:
        <<remove-task>>
#+end_src
* LOCK-STATUS
** 下行命令
#+begin_src nim :noweb-ref lock-status
  var lock_status: ref Parameter = new(Parameter)
  lock_status.board = cast[int8](task["board"].getNum())
  lock_status.pin = cast[int16](task["pin"].getNum())
  var pkt = lock_status.encode_as(CommandType.LOCK_STATUS, uid)
  discard task_buffer.add((uid: uid, sockaddr: dst, data: pkt))
  var saddr = dst
  <<ntop>>
  info "Prepare to send LOCK_STATUS(board: ", lock_status.board, ", pin: ", lock_status.pin, ") to ", uid, " @ ", address, ":", dst.sin_port
#+end_src
** 上行响应
#+begin_src nim :noweb-ref lock-status-confirm
  info "Confirm cmd type is LOCK_STATUS, board: ", param.board, ", state0: ", param.states[0].toHex(), ", state1: ", param.states[1].toHex(), ", state2: ", param.states[2].toHex()
  for i in 0..len(param.states) - 1:
    var state = param.states[i]
    for j in 0..7:
      var skey = "lock-status." & $uid & "." & $param.board & "." & $((len(param.states) - 1 - i) * 8 + j + 1)
      if ((1 shl j) and state) != 0:
        discard await redis_client.setEx(skey, 5, "1")
      else:
        discard await redis_client.setEx(skey, 5, "0")
  for taskstr in taskstrs:
    let task = try: parseJson(taskstr) except: nil
    if task != nil and task["command"].getStr() == "lock-status" and cast[int8](task["board"].getNum()) == param.board:
      <<remove-task>>
#+end_src
* LOCK-DETECT
** 下行命令
#+begin_src nim :noweb-ref lock-detect
  var lock_detect: ref Parameter = new(Parameter)
  lock_detect.board = cast[int8](task["board"].getNum())
  lock_detect.pin = cast[int16](task["pin"].getNum())
  var pkt = lock_detect.encode_as(CommandType.LOCK_DETECT, uid)
  discard task_buffer.add((uid: uid, sockaddr: dst, data: pkt))
  var saddr = dst
  <<ntop>>
  info "Prepare to send LOCK_DETECT(board: ", lock_detect.board, ", pin: ", lock_detect.pin, ") to ", uid, " @ ", address, ":", dst.sin_port
#+end_src
** 上行响应
#+begin_src nim :noweb-ref lock-detect-confirm
  info "Confirm cmd type is LOCK_DETECT, board: ", param.board, ", state0: ", param.states[0], ", state1: ", param.states[1], ", state2: ", param.states[2]
  for i in 0..len(param.states) - 1:
    var state = param.states[i]
    for j in 0..7:
      var skey = "lock-detect." & $uid & "." & $param.board & "." & $((len(param.states) - 1 - i) * 8 + j + 1)
      if ((1 shl j) and state) != 0:
        discard await redis_client.setEx(skey, 5, "1")
      else:
        discard redis_client.setEx(skey, 5, "0")
  for taskstr in taskstrs:
    let task = try: parseJson(taskstr) except: nil
    if task != nil and task["command"].getStr() == "lock-detect" and cast[int8](task["board"].getNum()) == param.board:
      <<remove-task>>
#+end_src
* LOCK-STATUS-DETECT
** 下行命令
#+begin_src nim :noweb-ref lock-status-detect
  var lock_status: ref Parameter = new(Parameter)
  lock_status.board = cast[int8](task["board"].getNum())
  lock_status.pin = cast[int16](task["pin"].getNum())
  var pkt = lock_status.encode_as(CommandType.LOCK_STATUS_DETECT, uid)
  discard task_buffer.add((uid: uid, sockaddr: dst, data: pkt))
  var saddr = dst
  <<ntop>>
  info "Prepare to send LOCK_STATUS_DETECT(board: ", lock_status.board, ", pin: ", lock_status.pin, ") to ", uid, " @ ", address, ":", dst.sin_port
#+end_src
** 上行响应

响应里包括两个部分的数据，states 里存放的是锁的状态，locks 里存放的是测物条的状态

#+begin_src nim :noweb-ref lock-status-detect-confirm
  info "Confirm cmd type is LOCK_STATUS_DETECT, board: ", param.board, ", status: ", param.states[0], ", ", param.states[1], ", ", param.states[2], ", detect: ", param.locks[0], ", ", param.locks[1], ", ", param.locks[2]
  for i in 0..len(param.states) - 1:
    var state = param.states[i]
    for j in 0..7:
      var skey = "lock-status." & $uid & "." & $param.board & "." & $((len(param.states) - 1 - i) * 8 + j + 1)
      if ((1 shl j) and state) != 0:
        discard await redis_client.setEx(skey, 5, "1")
      else:
        discard await redis_client.setEx(skey, 5, "0")
  for i in 0..len(param.locks) - 1:
    var state = param.locks[i]
    for j in 0..7:
      var skey = "lock-detect." & $uid & "." & $param.board & "." & $((len(param.locks) - 1 - i) * 8 + j + 1)
      if ((1 shl j) and state) != 0:
        discard await redis_client.setEx(skey, 5, "1")
      else:
        discard await redis_client.setEx(skey, 5, "0")
  for taskstr in taskstrs:
    let task = try: parseJson(taskstr) except: nil
    if task != nil and task["command"].getStr() == "lock-status-detect" and cast[int8](task["board"].getNum()) == param.board:
      <<remove-task>>
#+end_src
* LOCK-DATA
设备定时把锁控板的状态和测物条的状态上报给服务端，服务端把这些状态同步到缓存中。
** 上行命令
#+begin_src nim :noweb-ref lock-data
  let
    uid = data.uid
    param = data.parameter
    sn = param.sn
    now = cast[int]((epochTime() * 1000).toInt() shr 10)
    timestamp = cast[int](param.timestamp shr 10)
    expires_at = if now > timestamp: 5 else: timestamp - now
  <<save-connections>>

  info "LOCK-DATA, board: ", param.board, ", status: ", param.states[0], ", ", param.states[1], ", ", param.states[2], ", detect: ", param.locks[0], ", ", param.locks[1], ", ", param.locks[2]
  for i in 0..len(param.states) - 1:
    var state = param.states[i]
    for j in 0..7:
      var skey = "lock-status." & $uid & "." & $param.board & "." & $((len(param.states) - 1 - i) * 8 + j + 1)
      if ((1 shl j) and state) != 0:
        discard await redis_client.setEx(skey, expires_at, "1")
      else:
        discard await redis_client.setEx(skey, expires_at, "0")
  for i in 0..len(param.locks) - 1:
    var state = param.locks[i]
    for j in 0..7:
      var skey = "lock-detect." & $uid & "." & $param.board & "." & $((len(param.locks) - 1 - i) * 8 + j + 1)
      if ((1 shl j) and state) != 0:
        discard await redis_client.setEx(skey, expires_at, "1")
      else:
        discard await redis_client.setEx(skey, expires_at, "0")
  <<lock-data-confirm>>
#+end_src
** 下行响应
#+begin_src nim :noweb-ref lock-data-confirm
  var confirm_param: ref Parameter = new(Parameter)
  confirm_param.sn = sn
  confirm_param.version = 0
  confirm_param.cmd_type = 18 # CommandType.LOCK_DATA
  confirm_param.zone = 8 * 60 * 60 * 1000
  confirm_param.timestamp = cast[int64]((epochTime() * 1000).toInt())
  var pkt = confirm_param.encode_as(CommandType.CONFIRM, uid)
  discard task_buffer.add((uid: uid, sockaddr: saddr, data: pkt))
  info "Prepare to send CONFIRM of LOCK_DATA to ", uid, " @ ", address, ":", saddr.sin_port
#+end_src

* LIGHT-ON
** 下行命令
#+begin_src nim :noweb-ref light-on
  var light_on: ref Parameter = new(Parameter)
  light_on.pin = cast[int16](task["pin"].getNum())
  var pkt = light_on.encode_as(CommandType.LIGHT_ON, uid)
  discard task_buffer.add((uid: uid, sockaddr: dst, data: pkt))
  var saddr = dst
  <<ntop>>
  info "Prepare to send LIGHT_ON(pin: ", light_on.pin, ") to ", uid, " @ ", address, ":", dst.sin_port
#+end_src
** 上行响应
#+begin_src nim :noweb-ref light-on-confirm
  info "Confirm cmd type is LIGHT_ON"
  for taskstr in taskstrs:
    let task = try: parseJson(taskstr) except: nil
    if task != nil and task["command"].getStr() == "light-on":
      <<remove-task>>
#+end_src
* LIGHT-OFF
** 下行命令
#+begin_src nim :noweb-ref light-off
  var light_off: ref Parameter = new(Parameter)
  light_off.pin = cast[int16](task["pin"].getNum())
  var pkt = light_off.encode_as(CommandType.LIGHT_OFF, uid)
  discard task_buffer.add((uid: uid, sockaddr: dst, data: pkt))
  var saddr = dst
  <<ntop>>
  info "Prepare to send LIGHT_Off(pin: ", light_off.pin, ") to ", uid, " @ ", address, ":", dst.sin_port
#+end_src
** 上行响应
#+begin_src nim :noweb-ref light-off-confirm
  info "Confirm cmd type is LIGHT_OFF"
  for taskstr in taskstrs:
    let task = try: parseJson(taskstr) except: nil
    if task != nil and task["command"].getStr() == "light-off":
      <<remove-task>>
#+end_src
* FAN-ON
** 下行命令
#+begin_src nim :noweb-ref fan-on
  var fan_on: ref Parameter = new(Parameter)
  fan_on.pin = cast[int16](task["pin"].getNum())
  var pkt = fan_on.encode_as(CommandType.FAN_ON, uid)
  discard task_buffer.add((uid: uid, sockaddr: dst, data: pkt))
  var saddr = dst
  <<ntop>>
  info "Prepare to send FAN_ON(pin: ", fan_on.pin, ") to ", uid, " @ ", address, ":", dst.sin_port
#+end_src
** 上行响应
#+begin_src nim :noweb-ref fan-on-confirm
  info "Confirm cmd type is FAN_ON"
  for taskstr in taskstrs:
    let task = try: parseJson(taskstr) except: nil
    if task != nil and task["command"].getStr() == "fan-on":
      <<remove-task>>
#+end_src
* FAN-OFF
** 下行命令
#+begin_src nim :noweb-ref fan-off
  var fan_off: ref Parameter = new(Parameter)
  fan_off.pin = cast[int16](task["pin"].getNum())
  var pkt = fan_off.encode_as(CommandType.FAN_OFF, uid)
  discard task_buffer.add((uid: uid, sockaddr: dst, data: pkt))
  var saddr = dst
  <<ntop>>
  info "Prepare to send FAN_OFF(pin: ", fan_off.pin, ") to ", uid, " @ ", address, ":", dst.sin_port
#+end_src
** 上行响应
#+begin_src nim :noweb-ref fan-off-confirm
  info "Confirm cmd type is FAN_OFF"
  for taskstr in taskstrs:
    let task = try: parseJson(taskstr) except: nil
    if task != nil and task["command"].getStr() == "fan-off":
      <<remove-task>>
#+end_src
* ULTRAVIOLET-ON
** 下行命令
#+begin_src nim :noweb-ref ultraviolet-on
  var ultraviolet_on: ref Parameter = new(Parameter)
  ultraviolet_on.pin = cast[int16](task["pin"].getNum())
  var pkt = ultraviolet_on.encode_as(CommandType.ULTRAVIOLET_ON, uid)
  discard task_buffer.add((uid: uid, sockaddr: dst, data: pkt))
  var saddr = dst
  <<ntop>>
  info "Prepare to send ULTRAVIOLET_ON(pin: ", ultraviolet_on.pin, ") to ", uid, " @ ", address, ":", dst.sin_port
#+end_src
** 上行响应
#+begin_src nim :noweb-ref ultraviolet-on-confirm
  info "Confirm cmd type is ULTRAVIOLET_ON"
  for taskstr in taskstrs:
    let task = try: parseJson(taskstr) except: nil
    if task != nil and task["command"].getStr() == "ultraviolet-on":
      <<remove-task>>
#+end_src
* ULTRAVIOLET-OFF
** 下行命令
#+begin_src nim :noweb-ref ultraviolet-off
  var ultraviolet_off: ref Parameter = new(Parameter)
  ultraviolet_off.pin = cast[int16](task["pin"].getNum())
  var pkt = ultraviolet_off.encode_as(CommandType.ULTRAVIOLET_OFF, uid)
  discard task_buffer.add((uid: uid, sockaddr: dst, data: pkt))
  var saddr = dst
  <<ntop>>
  info "Prepare to send ULTRAVIOLET_OFF(pin: ", ultraviolet_off.pin, ") to ", uid, " @ ", address, ":", dst.sin_port
#+end_src
** 上行响应
#+begin_src nim :noweb-ref ultraviolet-off-confirm
  info "Confirm cmd type is ULTRAVIOLET_OFF"
  for taskstr in taskstrs:
    let task = try: parseJson(taskstr) except: nil
    if task != nil and task["command"].getStr() == "ultraviolet-off":
      <<remove-task>>
#+end_src

* CAMERA-ON
** 下行命令
#+begin_src nim :noweb-ref camera-on
  var camera_on: ref Parameter = new(Parameter)
  camera_on.pin = cast[int16](task["pin"].getNum())
  var pkt = camera_on.encode_as(CommandType.CAMERA_ON, uid)
  discard task_buffer.add((uid: uid, sockaddr: dst, data: pkt))
  var saddr = dst
  <<ntop>>
  info "Prepare to send CAMERA_ON(pin: ", camera_on.pin, ") to ", uid, " @ ", address, ":", dst.sin_port
#+end_src
** 上行响应
#+begin_src nim :noweb-ref camera-on-confirm
  info "Confirm cmd type is CAMERA_ON"
  for taskstr in taskstrs:
    let task = try: parseJson(taskstr) except: nil
    if task != nil and task["command"].getStr() == "camera-on":
      <<remove-task>>
#+end_src
* CAMERA-OFF
** 下行命令
#+begin_src nim :noweb-ref camera-off
  var camera_off: ref Parameter = new(Parameter)
  camera_off.pin = cast[int16](task["pin"].getNum())
  var pkt = camera_off.encode_as(CommandType.CAMERA_OFF, uid)
  discard task_buffer.add((uid: uid, sockaddr: dst, data: pkt))
  var saddr = dst
  <<ntop>>
  info "Prepare to send CAMERA_OFF(pin: ", camera_off.pin, ") to ", uid, " @ ", address, ":", dst.sin_port
#+end_src
** 上行响应
#+begin_src nim :noweb-ref camera-off-confirm
  info "Confirm cmd type is CAMERA_OFF"
  for taskstr in taskstrs:
    let task = try: parseJson(taskstr) except: nil
    if task != nil and task["command"].getStr() == "camera-off":
      <<remove-task>>
#+end_src

* CHARGER-STATUS
** 下行命令
#+begin_src nim :noweb-ref charger-status
  var charger_status: ref Parameter = new(Parameter)
  var pkt = charger_status.encode_as(CommandType.CHARGER_STATUS, uid)
  discard task_buffer.add((uid: uid, sockaddr: dst, data: pkt))
  var saddr = dst
  <<ntop>>
  info "Prepare to send CHARGER_STATUS(pin: ", charger_status.pin, ") to ", uid, " @ ", address, ":", dst.sin_port
#+end_src
** 上行响应
#+begin_src nim :noweb-ref charger-status-confirm
  info "Confirm cmd type is CHARGER_STATUS, charger1: ", param.chargers[0], ", charger2: ", param.chargers[1], ", charger3: ", param.chargers[2], ", charger4: ", param.chargers[3]
  for i in 0..len(param.chargers) - 1:
    var
      state = param.chargers[i]
      skey = "charger-status." & $uid & "." & $(i + 1)
    discard await redis_client.setEx(skey, 30, $state)
  for taskstr in taskstrs:
    let task = try: parseJson(taskstr) except: nil
    if task != nil and task["command"].getStr() == "charger-status":
      <<remove-task>>
#+end_src
* PLAY
** 下行命令
#+begin_src nim :noweb-ref play
  var play: ref Parameter = new(Parameter)
  play.pin = cast[int16](task["pin"].getNum())
  play.audio = cast[int8](task["audio"].getNum())
  play.card_reader = cast[int8](task["card-reader"].getNum())
  var pkt = play.encode_as(CommandType.PLAY, uid)
  discard task_buffer.add((uid: uid, sockaddr: dst, data: pkt))
  var saddr = dst
  <<ntop>>
  info "Prepare to send PLAY(card-reader: ", play.card_reader, ", audio: ", play.audio, ") to ", uid, " @ ", address, ":", dst.sin_port
#+end_src
** 上行响应
#+begin_src nim :noweb-ref play-confirm
  info "Confirm cmd type is play, card-reader: ", param.card_reader, ", audio: ", param.audio
  for taskstr in taskstrs:
    let task = try: parseJson(taskstr) except: nil
    if task != nil and task["command"].getStr() == "play" and task["card-reader"].getNum() == param.card_reader and task["audio"].getNum() == param.audio:
      <<remove-task>>
#+end_src
* 数据封包
#+begin_src nim :exports code :noweb yes :mkdirp yes :tangle /dev/shm/box-service/src/box_servicepkg/box_packer.nim
  import parameter, zeropack
  import hashes, logging, sequtils, strutils
  type
    CommandType* {.pure.} = enum
      UNKNOWN = 0, PING = 1, PONG = 2, CONFIRM = 3, LOCK_OFF = 4, LOCKS_OFF = 5, LOCK_STATUS = 6, LOCK_DETECT = 7, LOCK_STATUS_DETECT = 8, CHARGER_STATUS = 9, LIGHT_ON = 10, LIGHT_OFF = 11, FAN_ON = 12, FAN_OFF = 13, ULTRAVIOLET_ON = 14, ULTRAVIOLET_OFF = 15, CAMERA_ON = 16, CAMERA_OFF = 17, LOCK_DATA = 18, PLAY = 19
    UID* = array[0..11, byte]
    PackResultObject* = object of RootObj
      uid*: UID
      cmd_type*: CommandType
      parameter*: ref Parameter
    PackResult* = ref PackResultObject

  const version: int = 0
  const CRC8_KEY: uint8 = 0x07

  proc `$`*(uid: UID): string =
    return uid.mapIt(toHex(cast[BiggestInt](it), 2)).join("-")

  proc hash*(x: UID): Hash =
    let
      byte0 = x[0] xor x[4] xor x[8]
      byte1 = x[1] xor x[5] xor x[9]
      byte2 = x[2] xor x[6] xor x[10]
      byte3 = x[3] xor x[7] xor x[11]
    result = (cast[int](byte0) shl 24) + (cast[int](byte1) shl 16) + (cast[int](byte2) shl 8) + cast[int](byte3)

  proc parseUID*(uidstr: string): UID =
    let bytes = uidstr.split('-').mapIt(cast[byte](parseHexInt(it)))
    result[0] = bytes[0]
    result[1] = bytes[1]
    result[2] = bytes[2]
    result[3] = bytes[3]
    result[4] = bytes[4]
    result[5] = bytes[5]
    result[6] = bytes[6]
    result[7] = bytes[7]
    result[8] = bytes[8]
    result[9] = bytes[9]
    result[10] = bytes[10]
    result[11] = bytes[11]

  proc crc8(buf: seq[byte], offset: int, len: int): uint8 =
    var bptr = offset
    let stop = offset + len
    while bptr != stop:
      var i: uint8 = 0x80
      while i != 0:
        if (result and 0x80) != 0:
          result = result shl 1
          result = result xor CRC8_KEY
        else:
          result = result shl 1
        if (buf[bptr] and i) != 0:
          result = result xor CRC8_KEY
        i = i shr 1
      bptr += 1

  proc encode(payload: seq[byte], cmd_type: CommandType, uid: UID): seq[byte] =
    let
      payload_size = len(payload)
      header_size = 1 + 1 + 1 + 12
      size: int = header_size + payload_size
      uid_start = 3
    var buf: seq[byte] = newSeq[byte](size)
    buf[0] = cast[byte](size and 0xFF)
    buf[2] = cast[byte](ord(cmd_type))
    for i in 0..11:
      buf[uid_start + i] = uid[i]
    var payload_start = header_size
    for i in 0..(payload_size - 1):
      buf[payload_start + i] = payload[i]
    buf[1] = crc8(buf, 2, payload_size + header_size - 2)
    return buf

  proc encode_as*(parameter: ref Parameter, cmd_type: CommandType, uid: UID): seq[byte] =
    let size: int = parameter.calculate_size()
    var buf: seq[byte] = newSeq[byte](size)
    discard parameter.encode_into(buf, 0)
    let zipped_buf = zeropack(buf)
    return encode(zipped_buf, cmd_type, uid)

  proc decode*(buf: seq[byte], offset: int, length: int): PackResult =
    let
      header_size = 1 + 1 + 1 + 12
      packed_size = cast[int](buf[offset])
    if length != packed_size:
      warn "Length is invalid, got ", $length, " but need ", packed_size
      #echo hexdump(buf, length)
      return nil
    let checksum: uint8 = crc8(buf, offset + 2, length - 2)
    if checksum != buf[offset + 1]:
      warn "Checksum is invalid, got ", buf[offset + 1], " but should be ", checksum, "\n"
      return nil
    var uid: UID
    for i in 0..11:
      uid[i] = buf[offset + 1 + 1 + 1 + i]
    let unzipped: seq[byte] = unzeropack(buf, offset + header_size, length - header_size)
    let cmdtype = buf[offset + 1 + 1]
    if cmdtype < 19:
      result = PackResult(cmd_type: CommandType(cmdtype), uid: uid, parameter: parameter.decode_from(unzipped, 0))
    else:
      warn "Command type is invalid\n"
      return nil
#+end_src
* 支援方法
** 保存连接

将设备的地址和对应的 Socket Address 保存到 device_connections 中，以后可以根据此
地址，主动给设备发送数据。同时把设备的地址加入到当前活跃设备集合中。

#+begin_src nim :noweb-ref save-connections
  device_connections[uid] = (expires_at: epochTime().toInt() + 60 * 1024, sockaddr: saddr)
  let activated_key = "box.activated." & getDateStr() & "." & $getLocalTime(getTime()).hour.format("02d") & "." & $getLocalTime(getTime()).minute.format("02d")
  discard await redis_client.sAdd(activated_key, $uid)
#+end_src

** hexdump

#+begin_src nim :noweb-ref hexdump
  proc hexdump(buf: seq[byte], size: int): string =
    var output = ""
    for i in 0..(size - 1):
      output.add("$1 " % (toHex(buf[i])))
      if i mod 8 == 7:
        output.add("\n")
    return output
#+end_src
** 转换IP地址为字符串

#+begin_src nim :noweb-ref ntop
  discard inet_ntop(posix.AF_INET, cast[pointer](addr saddr.sin_addr), cstring(address), len(address).int32)
  address = address.strip(chars = {'\0'})
#+end_src

** 从缓存中删除已完成任务

#+begin_src nim :noweb-ref remove-task
  discard await redis_client.lrem(taskkey, taskstr, 1)
  <<update-status-to-sent>>
  info "Remove from redis ", taskstr
#+end_src
